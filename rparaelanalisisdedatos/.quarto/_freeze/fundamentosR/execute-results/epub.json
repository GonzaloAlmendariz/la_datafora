{
  "hash": "901c5c13e652db393d1618c6d9592313",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  warning: false\n  message: false\n---\n\n\n\n\n\n# Fundamentos de R\n\nEn el capitulo anterior establecimos la importancia de la ciencia estadística para la investigación. Hacer análisis estadístico implica necesariamente realizar numerosos cálculos matemáticos, organizar los resultados y crear gráficos que representen adecuadamente los hallazgos de nuestra investigación. Para ello, han surgido numerosos programas de análisis estadístico, cada uno con enfoques y características particulares. Una de esas herramientas es **R**, el lenguaje de programación que utilizaremos en esta guía para explorar los fundamentos de la estadística.\n\nR es un lenguaje de programación y un entorno de software **creado específicamente para el análisis estadístico y la representación gráfica**. Fue desarrollado en la década de 1990 por los estadísticos Ross Ihaka y Robert Gentleman [@datacampAllAboutR] . El lenguaje R fue desarrolado como un esfuerzo por diseñar una herramienta que facilite la aplicación de métodos estadísticos desde básicos hasta avanzados y que sea lo suficientemente flexible para adaptarse a diversas necesidades de investigación y análisis.\n\nLa mayor ventaja de R radica en que es un software de código abierto y gratuito, lo que significa que no existen barreras económicas, cualquiera puede descargarlo y usarlo sin costo alguno. Esto ha asegurado que tenga una comunidad activa que continuamente expande sus capacidades inclso fuera del análsis estadístico.\n\nPor lo tanto, R es una herramienta sumamente útil para realizar una gran conjuto de tareas, muchas de ellas necesarias para responder a las preguntas planteadas en nuestra investigación. Estas tareas incluyen:\n\n-   **Manipulación y limpieza de datos:** Filtrar, transformar y limpiar conjuntos de datos para organizarlos y prepararlos de manera adecuada para el análisis posterior.\n\n-   **Análisis descriptivo:** Resumir y describir los datos utilizando diversas medidas, como promedios, medianas y desviaciones estándar, para comprender sus características principales.\n\n-   **Creación de gráficos y visualización de datos:** Crear gráficos simples, como gráficos de barras y líneas, hasta visualizaciones complejas que muestren relaciones y patrones en los datos.\n\n-   **Modelado estadístico:** Aplicar técnicas como regresión lineal y no lineal, análisis de varianza y modelos multivariantes para comprender, interpretar y explorar las relaciones entre objetos.\n\n## R como lenguaje de programación\n\nPara dar un poco de contexto, cuando decimos que R es un **\"lenguaje de programación\"**, nos referimos a que, en este sistema, los usuarios **escribimos código**, y es la máquina la que se encarga de ejecutar las instrucciones, llevando a cabo las tareas que queramos realizar. A diferencia de otros programas que utilizan botones o menús predefinidos, en R el código es el protagonista: aquí especificamos, paso a paso, las operaciones que queremos ejecutar.\n\n![Ejemplo de código en r. Elaboración propia](images/carbon-2.png){fig-align=\"center\"}\n\nLlamamos \"lenguaje\" a estos sistemas porque tienen mucho en común con los idiomas humanos. Así como en español necesitamos un vocabulario para expresar ideas, en R contamos con funciones, objetos y operadores que nos permiten comunicarnos con la computadora. De manera similar, la gramática en un idioma dicta cómo organizar las palabras para construir frases coherentes, y en R la sintaxis define cómo estructurar el código para que sea comprensible y funcional.\n\nPiensa por un momento en cómo aprendes un nuevo idioma: primero necesitas familiarizarte con su vocabulario, entender las reglas gramaticales que rigen cómo se estructuran las oraciones y luego practicar combinándolos para expresar ideas más complejas. Aprender R no es muy diferente. El código es su vocabulario, compuesto por funciones, objetos y operadores que utilizamos para comunicar instrucciones a la computadora.\n\nAl igual que hay múltiples idiomas, también existen muchos lenguajes de programación, cada uno adaptado a propósitos específicos. Python, por ejemplo, es conocido por su uso en inteligencia artificial y desarrollo web, mientras que SQL se utiliza para gestionar bases de datos. Si bien esta guia no tocará otros lenguajes espero también te sirva sirve como una excelente introducción al mundo de la programación.\n\n## Instalación de R y RStudio\n\nPara utilizar R desde nuestras computadoras, debemos instalar R y RStudio, ya que ambos se utilizan conjuntamente. Sin embargo, no son lo mismo:\n\n-   **R:** Es el lenguaje de programación y entorno de software en el que se realizan análisis estadísticos y se crean paquetes. R forma la base que necesitaremos para realizar cálculos, análisis y visualización de datos.\n-   **RStudio:** Un entorno de desarrollo integrado (IDE) para R, usado para escribir scripts y ejecutar análisis, así como para producir informes. RStudio proporciona una interfaz más fácil y amigable de navegar además de añadir otras herramientas útiles al momento de trabajar.\n\n> Un **IDE (Entorno de Desarrollo Integrado)** es un programa que ayuda de manera inteligente a escribir y ejecutar el código de manera organizada. Es una herramienta todo en uno que cuenta con un área para escribir el código, verificar errores, ejecutarlo y ver los resultados. También tiene características útiles, como resaltado de comandos e intentat predecir tu próximo código y darte sugerencias de opciones mientras se escribe.\n\n**Pasos para instalar R:**\n\n1.  Visita la página oficial de [R](https://www.r-project.org/).\n2.  Dirígete a la sección de descargas y selecciona el enlace apropiado para tu sistema operativo (Windows, macOS, Linux).\n3.  Sigue las instrucciones de instalación.\n\n**Pasos para instalar RStudio:**\n\n1.  Visita la página oficial de [RStudio](https://www.rstudio.com/).\n2.  Navega a la sección de descargas y selecciona \"RStudio Desktop\".\n3.  Elige el instalador adecuado para tu sistema operativo y sigue las instrucciones de instalación.\n\n## Interfaz\n\nPara empezar, vamos a utilizar RStudio. Lo primero que debemos hacer es familiarizarnos con la interfaz. Al abrirlo, probablemente lo primero que veas es lo siguiente.\n\n![Extraído de RStudio User Guide](images/clipboard-2730531706.png)\n\nHay cuatro paneles, cada uno indispensable y con un conjunto de funcionalidades:\n\n1.  **Source**: Todo el código que escribes en R se realiza en el panel Source. El código R es simplemente tu conjunto de instrucciones en el lenguaje R para que la computadora complete las tareas dadas.\n2.  **Consola**: La consola es la consola interactiva R. Aquí es donde la mayoría de las funciones se ejecutan al instante. Aquí es donde aparecen los resultados de los cálculos y procedimientos que hemos solicitado al programa. Se utiliza principalmente para una verificación rápida y también para ver el resultado de tus scripts.\n3.  **Entorno**: La pestaña Entorno es la lista de todos los objetos que has creado en tu trabajo. Algunos ejemplos de objetos son vectores, matrices, marcos de datos, listas, gráficos y funciones.\n4.  **Archivos/Gráficos/Paquetes/Ayuda**:\n    -   **Archivos**: Son para navegar por el sistema de archivos de tu computadora directamente desde RStudio.\n    -   **Gráficos**: Después de ejecutar el código R, puedes ver las imágenes creadas por el código R.\n    -   **Paquetes**: La herramienta gestiona los paquetes que has instalado.\n    -   **Ayuda**: El equivalente de Google para R. Puedes buscar cualquier información sobre las funciones e incluso encontrar el tutorial necesario.\n\nLa ventaja original del panel **Source** es la **capacidad de editar rápidamente tu código**, el cual puedes volver a ejecutar. Este aspecto incluye tanto la reproductividad como la eficiencia; por ejemplo, podemos ajustar nuestro código sin rehacerlo desde cero. Además, podemos guardar nuestro trabajo como un archivo, podemos almacenar nuestros scripts en un editor de computadora, podemos distribuirlo, podemos editarlo o publicar este archivo nuevamente. Pero para trabajar de manera organizada, también es importante tener una buena estructura para almacenar todo lo relacionado con el proyecto.\n\nCuando trabajamos en proyectos de análisis de datos, es común manejar varios archivos relacionados: tus scripts (donde escribirás el código), los datos que analizarás y los resultados generados. Tener una carpeta específica para cada proyecto te ayuda a mantener todo organizado en un solo lugar. Además, R necesita saber dónde buscar y guardar los archivos, y eso se define mediante el **directorio de trabajo**, que es simplemente la carpeta donde R guardará y buscará archivos automáticamente.\n\n### Crear y configurar tu carpeta de trabajo\n\n1.  **Crea una carpeta específica**:\n    -   En tu dispositivo, crea una nueva carpeta para tu proyecto (por ejemplo, \"MiProyectoR\"). Este será el lugar donde guardarás todos los archivos relacionados.\n2.  **Establece la carpeta como directorio de trabajo**:\n    -   En RStudio, ve al panel **Files**, ubicado generalmente en la parte inferior derecha.\n\n        ![](images/7.png)\n\n    -   Puedes usar el botón **New Folder** para crear una nueva carpeta si aún no lo has hecho.\n\n    -   Navega hasta la carpeta que creaste y selecciona **More \\> Set As Working Directory**. Esto le dice a RStudio que todos los archivos guardados o abiertos estarán relacionados con esta carpeta.\n\n        ![](images/8.png)\n\n    -   Verás en la consola un mensaje como:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# setwd(\"ruta/de/tu/carpeta\")\n```\n:::\n\n\n\n\n\n### Crear un archivo de script\n\nCuando trabajamos en R, utilizamos diferentes tipos de archivos para organizar y guardar nuestro trabajo. Dos formatos comunes son el **archivo R Script** y el **documento Quarto**. Ambos se utilizan para escribir código, pero cumplen propósitos diferentes que es importante entender.\n\nUn **archivo R Script** es un archivo simple donde escribimos y guardamos nuestras instrucciones de código. Sirve como un registro de los comandos que ejecutamos, permitiendo reutilizarlos o ajustarlos más adelante. Sin embargo, este tipo de archivo no incluye espacio para explicaciones extensas ni muestra los resultados directamente junto al código.\n\nEn cambio, un **documento Quarto** va más allá al permitir combinar texto explicativo, bloques de código y los resultados generados (como tablas y gráficos) en un solo archivo. Además, es posible exportar el archivo final en formatos como HTML, PDF o Word, haciéndolo ideal para documentar y compartir análisis de manera profesional (de hecho, este libro esta hecho en Quarto). Esta capacidad de integrar explicación, análisis y presentación en un mismo lugar hace que Quarto sea particularmente útil para aprender y comunicar análisis de datos. En este libro, vamos a utilizar **documentos Quarto**.\n\n1.  **Accede a la ventana Files**:\n    -   En RStudio, localiza el panel **Files**. Este panel muestra el contenido de la carpeta de trabajo que configuraste previamente.\n2.  **Crea un nuevo documento Quarto**:\n    -   En el panel **Files**, haz clic en el botón **New File** y selecciona **Quarto Document**.\\\n        ![](images/9.png)\n    -   Aparecerá un cuadro de diálogo donde puedes configurar el título del documento, tu nombre y el formato de salida inicial (HTML es una buena opción para empezar). Haz clic en **Create**.\n3.  **Guarda automáticamente en la carpeta de trabajo**:\n    -   Cuando crees el documento desde la ventana **Files**, este se guardará automáticamente en tu carpeta de trabajo configurada. No necesitas realizar pasos adicionales para seleccionar la ubicación.\n\nEn un archivo Quarto puedes combinar texto explicativo (en formato Markdown) con bloques (chunks) de código en R. Los bloques de código son las secciones donde escribirás las instrucciones que deseas ejecutar, y están delimitados por tres backticks (\\`\\`\\`) seguidos del lenguaje que estás utilizando (en este caso, `r`). Para agregar un bloque de código de manera rápida, puedes utilizar el atajo de teclado:\n\n-   **Ctrl + Alt + I** en Windows y Linux.\\\n-   **Cmd + Option + I** en Mac.\n\nEste atajo insertará automáticamente un nuevo chunk en tu documento, con la estructura básica para que puedas empezar a escribir tu código. Un chunk de código tiene este formato:\n\n```{{r}}\n# Aquí escribes tu código en R\n```\n\nDentro del chunk, puedes incluir cualquier instrucción que se ejecutará cuando proceses el documento. Esto permite mantener el texto explicativo y el código separados pero integrados en el mismo archivo, lo que facilita la organización y presentación del análisis.\n\nEste enfoque es primordial para que trabajes directamente desde tu carpeta de trabajo, asegurando que todos los archivos relacionados con el proyecto estén organizados y listos para reproducir o compartir.\n\n### Flujo de trabajo\n\nCuando trabajamos con un documento Quarto, seguimos un flujo estructurado que combina texto explicativo, bloques de código y los resultados generados en un único archivo. Este flujo de trabajo organiza y centraliza nuestro análisis, garantizando que sea reproducible y fácil de compartir. Para ello, debemos entener el rol de cada panel.\n\n**La consola** en RStudio es el núcleo donde se procesan las instrucciones que escribimos. Cada vez que ejecutas un bloque de código, este se envía a la consola, donde R lo interpreta y devuelve un resultado. Piensa en la consola como el \"cerebro\" que recibe tus órdenes, las ejecuta y genera una respuesta, ya sea un cálculo, un gráfico o una tabla. La consola de RStudio es la sección donde puedes escribir código directamente y ejecutarlo inmediatamente al presionar **Enter**.\n\nAunque puedes escribir directamente en la consola, las instrucciones que ingresas allí no se guardan automáticamente, por lo que no es ideal para documentar o reproducir tu trabajo.\n\n![](images/clipboard-2228732215.png)\n\n**La fuente**, que en nuestor caso es un documento Quarto, actúa como un registro estructurado de tu análisis.\n\n![](images/clipboard-2971498337.png)\n\nDentro de él, puedes combinar texto explicativo con bloques de código llamados *chunks*. Para ejecutar un *chunk* completo:\n\n-   Haz clic en el botón **Play** que aparece en la esquina superior derecha del *chunk*.\n\n-   Alternativamente, coloca el cursor dentro del *chunk* y presiona:\n\n    -   **Ctrl + Shift + Enter** en Windows y Linux.\n\n    -   **Cmd + Shift + Enter** en Mac.\n\nAl ejecutar el *chunk*, todas las líneas dentro de él se enviarán a la consola para ser procesadas.\n\n![](images/clipboard-2866205978.png)\n\nEstos *chunks* permiten escribir instrucciones que la consola ejecutará, pero al estar integrados en el documento, también puedes guardarlos y reproducirlos en el futuro. Esto hace que el documento Quarto sea una herramienta ideal para registrar tus pasos, explicar tus decisiones y presentar los resultados de forma clara. Los gasos generalmente son los siguentes:\n\n![](images/clipboard-3132245154.png)\n\nEsta lógica nos permite:\n\n1.  **Escribir el código en un chunk**: Cada *chunk* de código se delimita por tres backticks (```` ``` ````) y se utiliza para dar instrucciones específicas a R. Por ejemplo:\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    5 + 5\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 10\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n    Este código le dice a R que sume 5 y 5. Cuando lo ejecutas, R procesa la operación en la consola y devuelve el resultado.\n\n2.  **Anotar el código con comentarios**: Para aclarar el propósito de una línea de código o hacer notas útiles, utilizamos el carácter `#`. Todo lo que escribas después de este símbolo será un comentario y no se ejecutará. Por ejemplo:\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    5 + 5 # Esto es una suma\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 10\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n    Aquí, el comentario sirve para explicar lo que hace esta línea.\n\n3.  **Texto explicativo**: Una de las ventajas de Quarto es que permite intercalar texto explicativo con los *chunks* de código. Esto facilita documentar el análisis y explicar los resultados, haciendo que el trabajo sea más comprensible y presentable.\n\n    ![](images/clipboard-243096251.png)\n\n> **Consola vs. documento Quarto: ¿cuándo usar cada uno?**\n>\n> **Escribir directamente en la consola**: Es útil para pruebas rápidas o cálculos sencillos que no necesitas guardar. Devuelve el resultado inmediatamente, pero no queda registrado.\n>\n> **Escribir en el documento Quarto**: Es ideal para cualquier análisis que quieras documentar, reproducir o compartir. Al escribir en un *chunk*, puedes ejecutar el código igual que en la consola, pero además quedará registrado junto con tus explicaciones y los resultados obtenidos.\n\nCuando completes tu análisis, haz clic en el botón **Render** en la parte superior del archivo Quarto.\n\n![](images/clipboard-278275421.png)\n\nPresiona este botón para ejecutar todo el código en la consola y también para producir el documento final con el formato seleccionado HTML (con más extensiones incluso puede exportar a PDF o Word). Garantiza que tu trabajo esté organizado, documentado y listo para ser publicado.\n\n## Objetos\n\nEn R, cualquier entidad que se cree y preserve en la memoria durante una sesión se llama objeto. Puede ser un número, un texto, un conjunto de datos, una función, un gráfico y así sucesivamente. Puedes almacenar datos en objetos y luego usarlos para cálculos o análisis. Para poder ah\\\\\\\\hacer ello, utilizamos el operador `=` o `<-` para asignar un valor a un objeto. Por ejemplo, podemos asignar el resultado de una operación a un objeto:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Asignar el valor 10 al objeto 'a'\na = 10\n\n# Asignar el resultado de una suma al objeto 'b'\nb <- 4 + 7\n```\n:::\n\n\n\n\n\nUna vez que un objeto ha sido asignado, podemos utilizarlo en operaciones posteriores:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sumar las objetos 'a' y 'b'\na + b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n:::\n\n\n\n\n\n### Nombrar un objeto\n\nPodemos declarar (nombrar) a un objeto como deseemos, pero su nombre no debe tener espacios. Por eso, a veces usamos guiones bajos (`_`) para conectar dos palabras, por ejemplo, `mi_objeto` o `resultado_final`.\n\nLas objetos se almacenan en el entorno (environment) de R y lo puedes apreciar en la ventana superior derecha del entorno de RStudio.\n\n![Elaboración propia](images/Observación-3.png)\n\n## Funciones\n\nAnteriormente mencionamos que R es un lenguaje de programación que nos permite comunicarnos con la computadora para que esta realice tareas utilizando nuestros datos (input) y nos devuelva un resultado (output). Para que estas tareas se lleven a cabo, primero debemos indicarle a la computadora cómo hacerlo, y estas indicaciones se dan a través de **funciones**. Las funciones son instrucciones representadas por palabras seguidas de paréntesis, que le dicen a R que ejecute una acción específica.\n\n![Elaboración propia](images/Observación-4.png)\n\nLas funciones en R pueden recibir **argumentos** (los valores que se colocan dentro del paréntesis). Estos argumentos pueden ser tanto los datos a procesar como instrucciones adicionales que le indican a la función cómo debe realizar la tarea.\n\nPor ejemplo, la función `sum()` sirve para sumar múltiples valores.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sumar 10, 20 y 30 usando la función sum()\nsum(10, 20, 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 60\n```\n\n\n:::\n:::\n\n\n\n\n\nLa función `round()` redondea un número, y podemos especificar cuántos decimales queremos conservar. Aquí, el primer argumento es el número a redondear, y el segundo es una instrucción que indica cuántos decimales mantener.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(2.54934, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.55\n```\n\n\n:::\n:::\n\n\n\n\n\nLas funciones son fundamentales para trabajar en R, son la columna vertebral del lenguaje y nos permiten realizar tareas de todo tipo, desde cálculos simples hasta análisis complejos de datos. Muchas funciones ya vienen incluidas en R, pero otras han sido creadas por la comunidad y se encuentran en **paquetes** (que exploraremos más adelante). Además, tú mismo puedes crear tus propias funciones (Consulta el glosario de operaciones útiles, 12.0).\n\nPor eso, aquí tienes una tabla con una clasificación que te ayudará a explorarlas:\n\n| **Categoría** | **Función** | **Descripción** |\n|----|----|----|\n| **Matemáticas y Estadísticas** |  |  |\n| Realizan cálculos matemáticos o análisis estadísticos sobre los datos. | `sum()` | Suma todos los valores proporcionados. |\n|  | `mean()` | Calcula el promedio de un conjunto de datos. |\n|  | `sd()` | Calcula la desviación estándar de un conjunto de datos. |\n|  | `round()` | Redondea un número al número de decimales especificado. |\n|  | `log()` | Calcula el logaritmo de un número en la base especificada (por defecto, base e). |\n| **Manipulación de Datos** |  |  |\n| Estas funciones permiten estructurar, transformar y filtrar conjuntos de datos para su análisis. | `length()` | Devuelve la longitud de un vector o lista. |\n|  | `head()` | Muestra las primeras filas de un conjunto de datos. |\n|  | `tail()` | Muestra las últimas filas de un conjunto de datos. |\n|  | `subset()` | Extrae subconjuntos de datos según una condición especificada. |\n|  | `merge()` | Combina dos conjuntos de datos en función de una clave común. |\n| **Visualización** |  |  |\n| Ayudan a crear gráficos y representaciones visuales de los datos para facilitar su interpretación. | `plot()` | Crea gráficos básicos a partir de datos. |\n|  | `hist()` | Genera un histograma para datos continuos. |\n|  | `boxplot()` | Crea un diagrama de caja para representar la dispersión de los datos. |\n|  | `barplot()` | Genera un gráfico de barras. |\n| **Control de Flujo** |  |  |\n| Permiten estructurar el código para que se ejecute en función de condiciones específicas. | `if()` | Ejecuta una acción si se cumple una condición. |\n|  | `else()` | Proporciona una alternativa cuando la condición de `if` no se cumple. |\n|  | `for()` | Itera a través de una secuencia y ejecuta una acción para cada elemento. |\n|  | `while()` | Repite una acción mientras se cumpla una condición. |\n| **Entrada/Salida** |  |  |\n| Facilitan leer datos de archivos y guardar los resultados en diversos formatos. | `read.csv()` | Lee datos desde un archivo CSV y los convierte en un marco de datos. |\n|  | `write.csv()` | Guarda un marco de datos en un archivo CSV. |\n|  | `readRDS()` | Carga datos guardados en formato RDS. |\n|  | `saveRDS()` | Guarda datos en formato RDS. |\n| **Modelado Estadístico** |  |  |\n| Permiten ajustar modelos y realizar análisis estadísticos avanzados. | `lm()` | Ajusta modelos lineales simples o múltiples. |\n|  | `glm()` | Ajusta modelos lineales generalizados. |\n|  | `summary()` | Proporciona un resumen estadístico de un modelo o conjunto de datos. |\n| **Transformación de Texto** |  |  |\n| Ayudan a operar sobre cadenas de texto, como combinarlas, dividirlas o cambiar su formato. | `paste()` | Combina varias cadenas de texto en una sola. |\n|  | `strsplit()` | Divide una cadena en partes según un separador. |\n|  | `toupper()` | Convierte texto a mayúsculas. |\n|  | `tolower()` | Convierte texto a minúsculas. |\n| **Trabajo con Fechas** |  |  |\n| Facilitan trabajar con datos que incluyen fechas y horas. | `Sys.Date()` | Devuelve la fecha actual del sistema. |\n|  | `as.Date()` | Convierte datos en formato de fecha. |\n|  | `difftime()` | Calcula la diferencia entre dos fechas. |\n\n**Nota:** No te precupes, no debes conocerlas todas aún. A medida que avancemos en el libro, exploraremos muchas de estas funciones en detalle. Sin embargo, te animo a echar un vistazo a su diversidad para que te familiarices con las capacidades que R ofrece.\n\n## Paquetes\n\nEn R, muchas de las cosas que queremos hacer se pueden realizar con \"paquetes\". En R, un paquete es generalmente un conjunto de herramientas con funciones específicas para realizar tareas específicas. Para casi todo hay paquetes. Por ejemplo, el paquete dplyr (6.5) es un paquete ampliamente utilizado para la manipulación de datos como filtrar valores o crear nuevas columnas. Pero antes, necesitamos entender la diferencia entre instalar un paquete y cargar un paquete en R.\n\n### Instalar un paquete\n\nMe gusta pensar que instalar un paquete en R es similar a ir a la tienda y comprar una caja de herramientas. Después de comprarla, la mueves a tu propio almacén para asegurarte de que la tendrás cuando la necesites. Esto solo necesita hacerse una vez por paquete, a menos que quieras actualizarlo (tener la última versión).\n\nCon R, instalamos un paquete con una función llamada `install.packages()` seguida del nombre del paquete entre comillas.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages('dplyr')\n```\n:::\n\n\n\n\n\n### Cargar un paquete\n\nCuando cargas un paquete en R, es como si sacaras la caja de herramientas del almacén y la pusieras en tu mesa de trabajo. Solo entonces las herramientas dentro de la caja te son accesibles para tus proyectos. Haces esto cada vez que comienzas un nuevo documento o una sesión de R.\n\nPara hacerlo, usamos la función `library()`.\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\nTambién puedes lograr esto con `::` si quieres usar una función completa de otro paquete, pero no quieres cargar el paquete completo. Bueno, esto es como sacar las herramientas de la caja, pero no poner toda la caja en tu mesa de trabajo.\n\nPor ejemplo, el paquete `psych` tiene una función `describe` que produce un resumen estadístico detallado de un conjunto de datos dado. Si queremos aplicarlo en un conjunto de datos predeterminado en R como `iris`, podemos hacerlo sin cargar todo `psych`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Usar la función describe del paquete psych con el conjunto de datos iris\npsych::describe(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             vars   n mean   sd median trimmed  mad min max range  skew\nSepal.Length    1 150 5.84 0.83   5.80    5.81 1.04 4.3 7.9   3.6  0.31\nSepal.Width     2 150 3.06 0.44   3.00    3.04 0.44 2.0 4.4   2.4  0.31\nPetal.Length    3 150 3.76 1.77   4.35    3.76 1.85 1.0 6.9   5.9 -0.27\nPetal.Width     4 150 1.20 0.76   1.30    1.18 1.04 0.1 2.5   2.4 -0.10\nSpecies*        5 150 2.00 0.82   2.00    2.00 1.48 1.0 3.0   2.0  0.00\n             kurtosis   se\nSepal.Length    -0.61 0.07\nSepal.Width      0.14 0.04\nPetal.Length    -1.42 0.14\nPetal.Width     -1.36 0.06\nSpecies*        -1.52 0.07\n```\n\n\n:::\n:::\n\n\n\n\n\nProporciona un resumen estadístico de los datos: media, desviación estándar, mínimo, máximo, etc., todo sin tener que cargar todo el paquete `psych`. Si nunca has escuchado sobre estas cosas antes, no te asustes, vamos a usar `psych` en la sección de Estadística Descriptiva (7.0) para calcular e interpretar estadísticas descriptivas para nuestros datos.\n\n**Recuerda:**\n\n-   Cuando **instalas un paquete**, estás tomando la caja de herramientas y asegurándola en tu propio almacén.\n\n-   **Cargar un paquete**, entonces, es poner esa caja de herramientas en tu mesa de trabajo para que puedas usar sus herramientas.\n\n-   **Importar una función del paquete** es como sacar una herramienta de la caja.\n\n## Elementos\n\nEn R, los **elementos** son las unidades básicas que componen los datos. Estos elementos tienen un **tipo de dato** que define su naturaleza, cómo pueden manipularse y las operaciones que pueden realizarse con ellos. Los **tipos de elementos** en R están directamente relacionados con los **tipos de variables** utilizados en análisis estadístico que vimos en el capítulo anterior, como variables numéricas (continuas y discretas), categóricas (nominales y ordinales) y lógicas (binarias).\n\n### Tipos de elementos\n\n**a. Logical (Lógicos)**\n\n-   Representan valores binarios: `TRUE` o `FALSE`.\n-   Asociados a variables dicotómicas en estadística.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- TRUE   # Elemento de tipo logical\ny <- FALSE\n```\n:::\n\n\n\n\n\nÚtil para **variables lógicas o binarias**, como \"aprobado\" (TRUE) y \"reprobado\" (FALSE).\n\n**b. Integer (Enteros)**\n\n-   Representan números enteros, como conteos o cantidades.\n-   Se definen agregando una \"L\" después del número.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 42L  # Elemento de tipo integer\ny <- -3L\n```\n:::\n\n\n\n\n\nÚtil para **variables numéricas discretas**, como número de hijos.\n\n**c. Numeric (Numéricos)**\n\n-   Representan números decimales o reales, como medidas continuas.\n-   Incluyen valores positivos, negativos y fracciones.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 7.85  # Elemento de tipo numeric\ny <- -23.2\n```\n:::\n\n\n\n\n\nDirectamente relacionado con **variables numéricas continuas**, como peso o altura.\n\n**d. Character (Cadenas de Texto)**\n\n-   Representan texto o cadenas de caracteres.\n-   Utilizados para datos categóricos o nominales.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"Peru\"  # Elemento de tipo character\ny <- \"Colombia\"\n```\n:::\n\n\n\n\n\n| **Tipo de Variable** | **Definición** | **En R** |\n|----|----|----|\n| **Numéricas Continuas** | Valores dentro de un rango continuo, como altura, peso, temperatura. | **Numeric**: Representa decimales o reales. |\n| **Numéricas Discretas** | Valores enteros que representan conteos, como número de personas o hijos. | **Integer**: Representa números enteros, sin decimales. |\n| **Categóricas Nominales** | Categorías sin un orden inherente, como colores o géneros. | **Character**: Representa texto (e.g., \"rojo\", \"azul\"). |\n| **Categóricas Ordinales** | Categorías con un orden lógico, como niveles educativos (bajo, medio, alto). | **Character o Factor**: Puede usarse texto, aunque los **factores** facilitan el orden. |\n| **Variables Lógicas (Binarias)** | Solo dos valores posibles, como `sí` o `no`, `aprobado` o `reprobado`. | **Logical**: Representa valores `TRUE` o `FALSE`. |\n\nPor ejemplo:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creamos distintos tipos de objetos\n\nnum = 3.5 \nlogic = FALSE\nchr = \"Peru\"\n\n# Los podemos mostrar con solo llamar el nombre de la objeto\n\nnum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.5\n```\n\n\n:::\n\n```{.r .cell-code}\nlogic\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nchr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Peru\"\n```\n\n\n:::\n:::\n\n\n\n\n\nUna forma muy práctica de asegurarnos qué tipo de elemento es la objeto es llamar a la función `class()`, simplemente tomando como argumento el nombre del objeto:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(num)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\n\nHagámoslo para el resto:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(logic)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(chr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n### Operaciones básicas\n\nEn R, los valores numéricos y lógicos son **elementos computables.** Es decir, pueden utilizarse para realizar operaciones matemáticas mediante operadores aritméticos. Los operadores más comunes incluyen:\n\n-   **Adición**: `+`\n-   **Sustracción**: `-`\n-   **Multiplicación**: `*`\n-   **División**: `/`\n-   **Exponencial**: `^`\n\nA continuación, algunos ejemplos prácticos:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Operaciones básicas\n4 + 7      # Suma: 11\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\n10 - 6     # Resta: 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n6 * 5      # Multiplicación: 30\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30\n```\n\n\n:::\n\n```{.r .cell-code}\n(4 + 2) / 2  # División: 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# Exponencial: 2 elevado a la potencia 5\n2^5       # Resultado: 32\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 32\n```\n\n\n:::\n:::\n\n\n\n\n\nLos valores **lógicos** (`TRUE` y `FALSE`) también pueden ser usados en operaciones matemáticas. R los interpreta como números:\n\n-   `TRUE` se considera igual a `1`\n-   `FALSE` se considera igual a `0`\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFALSE + TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nFALSE + FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE + TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\nUsar valores lógicos de esta forma puede ser muy útil, especialmente al trabajar con condiciones o conteos.\n\nA diferencia de los valores numéricos y lógicos, los **elementos caracteres** (`character`) no pueden participar en operaciones matemáticas. Sin embargo, pueden ser manipulados mediante funciones específicas para manejar texto, como `paste()` y `paste0()`, que permiten concatenar (unir) cadenas de texto.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto1 = \"Hola\"\ntexto2 = \"Mundo\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Concatenar texto con un espacio\npaste(texto1, texto2)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hola Mundo\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Concatenar texto sin espacio\npaste0(texto1, texto2)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HolaMundo\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Tipos de objetos\n\nUna vez establecido que un **elemento** se refiere al tipo de dato en sí mismo (como numérico, lógico o de caracteres). Ahora nos centraremos en los objetos. Un **objeto** es una estructura de datos que **puede contener uno o más elementos**. Los tipos de objetos principales incluyen **vectores**, **matrices**, **listas**, **dataframes** y **factores**.\n\n1.  **Vectores:**\n    -   Son una secuencia de elementos del mismo tipo.\n    -   Pueden ser de tipo numérico, lógico, o de caracteres.\n    -   Se pueden crear utilizando la función `c()`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ejemplo de vector numérico\nnumeros = c(1, 2, 3, 4, 5)\n   \n# Ejemplo de vector de caracteres\nletras = c(\"a\", \"b\", \"c\", \"d\", \"e\")\n\nnumeros\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nletras\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n```\n\n\n:::\n:::\n\n\n\n\n\n![El tipo de vector depende del tipo de elementos que contenga. Elaboración propia](images/clipboard-872070375.png)\n\n2.  **Matrices:**\n    -   Son una colección de elementos del mismo tipo, organizada en filas y columnas.\n    -   Se pueden crear utilizando la función `matrix()`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ejemplo de matriz numérica\nmatriz_numerica = matrix(1:9, nrow = 3, ncol = 3)\n   \n# Ejemplo de matriz de caracteres\nmatriz_caracteres = matrix(letters[1:9], nrow = 3, ncol = 3)\n\nmatriz_numerica\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n\n```{.r .cell-code}\nmatriz_caracteres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,] \"a\"  \"d\"  \"g\" \n[2,] \"b\"  \"e\"  \"h\" \n[3,] \"c\"  \"f\"  \"i\" \n```\n\n\n:::\n:::\n\n\n\n\n\n![El tipo de matriz también depende del tipo de elementos que contenga. Elaboración propia](images/clipboard-1049817961.png)\n\n3.  **Listas:**\n    -   Son una colección de objetos en un orden determinado que pueden ser de distintos tipos\n    -   Se pueden crear utilizando la función `list()`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ejemplo de lista\nmi_lista = list(numeros, letras, matriz_numerica)\n\nmi_lista\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n[[3]]\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n:::\n\n\n\n\n\n![Una lista es capaz de almacenar elementos e incluso objetos de todo tipo, incluso otras listas. Elaboración propia](images/Observación-5.png)\n\n4.  **Factores:**\n    -   Son una forma de sistematizar datos categóricos, puedes utilizarlos para ordenar tus variables ordinales o nominales.\n    -   Se pueden crear utilizando la función `factor()`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ejemplo de un factor\npreferencias_politicas = c(\"Liberal\", \"Conservador\", \"Progresista\", \n                           \"Liberal\", \"Conservador\", \"Progresista\", \n                           \"Liberal\", \"Conservador\")\n\n# Ejemplo de factor ordenado\ntemperaturas = c(\"Alta\", \"Baja\", \"Alta\", \"Media\", \"Baja\")\ntemperaturas = factor(temperaturas, \n                      levels = c(\"Baja\", \"Media\", \"Alta\"), \n                      ordered = TRUE)\n```\n:::\n\n\n\n\n\n![Elaboración propia](images/clipboard-3012874766.png)\n\n5.  **DataFrames:**\n    -   Son estructuras de datos tabulares similares a las tablas de una base de datos u hoja de cálculo.\n    -   Las columnas pueden tener diferentes tipos de datos.\n    -   Se pueden crear utilizando la función `data.frame()`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ejemplo de data frame\ndatos = data.frame(numeros, letras, temperaturas)\n\ndatos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  numeros letras temperaturas\n1       1      a         Alta\n2       2      b         Baja\n3       3      c         Alta\n4       4      d        Media\n5       5      e         Baja\n```\n\n\n:::\n:::\n\n\n\n\n\n![Los data.frames son uno de los objetos más comunes para almacenar conjuntos de datos. Elaboración propia](images/clipboard-2310458056.png)\n\nNos detendremos en este capítulo en los vectores, pues son el tipo de objeto que, junto con el data.frame, encontraremos más frecuentemente en nuestro trabajo diario analizando datos. El resto de ellos los veremos con mayor detalle en el transcurso de la guía.\n\n### Vectores\n\nComo ya habíamos dicho, un vector en R es una forma de almacenar y organizar una secuencia de elementos (*numeric, logical, character*) que podemos usar para diversas operaciones. Los vectores pueden contener números, texto o valores lógicos, y puedes realizar operaciones en todo el conjunto de valores en un vector a la vez.\n\nPara crear un vector solo debemos escribir la función `c()` y poner cada elemento como argumento de esta forma:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(2, 4, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6\n```\n\n\n:::\n:::\n\n\n\n\n\nPodemos asignarle este vector a una objeto y R lo reconocerá\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_vector = c(2, -4, 6)  \n\nmi_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2 -4  6\n```\n\n\n:::\n:::\n\n\n\n\n\nFunciona de la misma forma para elementos lógicos y de texto\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_vector_log = c(FALSE, TRUE, TRUE, FALSE)  \n\nmi_vector_chr = c(\"Hey\", \"un placer\")  \n\nmi_vector_log  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nmi_vector_chr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hey\"       \"un placer\"\n```\n\n\n:::\n:::\n\n\n\n\n\n### Operaciones con vectores\n\nAdemás de crearlos, también podemos realizar operaciones matemáticas directamente sobre ellos. Supongamos que tienes un vector con los valores:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_vector = c(2, 4, 6, 3, 9, 12)\n```\n:::\n\n\n\n\n\nSi sumas un número, este se aplica a cada elemento del vector:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_vector + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  5  7  4 10 13\n```\n\n\n:::\n:::\n\n\n\n\n\nMultiplicar un vector por un número aplica la operación a cada elemento:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_vector * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  8 12  6 18 24\n```\n\n\n:::\n:::\n\n\n\n\n\nEsto funciona con cualquier operador aritmético que necesites.\n\nSi tienes dos vectores de igual longitud, R combina los elementos en la misma posición para realizar la operación:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\notro_vector = c(1, 2, 3, 4, 14, 7)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_vector + otro_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  6  9  7 23 19\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_vector * otro_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   2   8  18  12 126  84\n```\n\n\n:::\n:::\n\n\n\n\n\nAdemás, R tiene funciones integradas para calcular estadísticas básicas sobre un vector. Estas son algunas de las más comunes:\n\n-   **Suma total de elementos**:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(mi_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 36\n```\n\n\n:::\n:::\n\n\n\n\n\n-   **Promedio de los valores**:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(mi_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\n\n\n-   **Máximo y mínimo del vector**:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(mi_vector)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n\n```{.r .cell-code}\nmin(mi_vector)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n-   **Producto de todos los elementos**:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprod(mi_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15552\n```\n\n\n:::\n:::\n\n\n\n\n\nAdicionalmente, puedes realizar comparaciones directamente sobre los elementos de un vector. Esto **genera un nuevo vector lógico** (`TRUE` o `FALSE`) basado en si se cumple o no la condición.\n\nEjemplo:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Siendo el vector\nmi_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  3  9 12\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_vector > 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\nRecuerda que R interpreta `TRUE = 1` y `FALSE = 0`. Combinar operaciones lógicas con funciones como `sum()` te permite contar cuántos elementos cumplen una condición:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(mi_vector > 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\n\nSi deseas verificar si *todos* los elementos cumplen una condición, puedes usar `all()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(mi_vector > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\nPara verificar si *algún* elemento cumple una condición, utiliza `any()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(mi_vector > 18)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n### Selección de elementos en vectores\n\nPuedes extraer elementos específicos usando corchetes `[]`. Para acceder a un elemento en una posición específica, indica su **índice** dentro de los corchetes. Esto significa acceder a un valor según su posición dentro del vector. En R, las posiciones comienzan en **1**, no en 0 como en otros lenguajes de programación (como Python, por eejmplo).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar el primer elemento del vector\nmi_vector[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\nEsto selecciona únicamente el elemento en la posición 1. Si quisieras acceder al tercer elemento, solo tienes que cambiar el índice:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar el tercer elemento del vector\nmi_vector[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\n\n\nSi necesitas varios elementos al mismo tiempo, puedes utilizar la función `c()` para indicar los índices que deseas seleccionar. Por ejemplo, si quieres el primer y el tercer elemento:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar el primer y cuarto elemento del vector\nmi_vector[c(1, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3\n```\n\n\n:::\n:::\n\n\n\n\n\nTambién puedes seleccionar un rango de elementos usando el operador `:`, que genera una secuencia de números. Por ejemplo, para seleccionar todos los elementos desde la posición 2 hasta la posición 4:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar un rango de elementos (del segundo al quinto)\nmi_vector[2:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 6 3 9\n```\n\n\n:::\n:::\n\n\n\n\n\nEn lugar de acceder a los elementos por su posición, también puedes utilizar **operadores de comparación** para filtrar elementos basándote en condiciones. Los operadores de comparación en R incluyen:\n\n-   `<` para menor que.\n-   `>` para mayor que.\n-   `<=` para menor o igual que.\n-   `>=` para mayor o igual que.\n-   `==` para igualdad.\n-   `!=` para desigualdad.\n\nCuando usas un operador de comparación en un vector, R evalúa cada elemento y selecciona los que cumplan la condición (TRUE). Por ejemplo:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar elementos mayores que 10\nmi_vector[mi_vector > 10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n\n\n\nEsto devuelve todos los elementos del vector que son mayores que 10. Si quisieras filtrar los elementos que son menores o iguales a 6, lo harías así:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar elementos menores o iguales a 6\nmi_vector[mi_vector <= 6]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6 3\n```\n\n\n:::\n:::\n\n\n\n\n\nLa comparación también funciona para buscar elementos iguales o diferentes a un valor específico. Por ejemplo, si quisieras encontrar solo los elementos iguales a 25:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar elementos iguales a 9\nmi_vector[mi_vector == 9]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n:::\n\n\n\n\n\nO si quisieras excluir un valor en particular, puedes usar `!=`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar elementos diferentes de 12\nmi_vector[mi_vector != 12]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6 3 9\n```\n\n\n:::\n:::\n\n\n\n\n\nCuando necesitas aplicar más de una condición al mismo tiempo, puedes combinar operadores de comparación con los operadores lógicos `&` y `|`. Estas combinaciones te permiten filtrar elementos basados en condiciones más complejas.\n\nCuando utilizas **`&`** , estás pidiendo que **todas las condiciones sean verdaderas** al mismo tiempo para que un elemento sea seleccionado. Esto significa que cada elemento del vector debe cumplir **cada condición individualmente**.\n\nSupongamos que quieres seleccionar elementos que sean mayores que 5 **y al mismo tiempo** menores que 10. La lógica es que un valor solo será seleccionado si cumple ambas condiciones. Así es como lo harías:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar elementos mayores que 5 y menores que 10\nmi_vector[mi_vector > 5 & mi_vector < 10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 9\n```\n\n\n:::\n:::\n\n\n\n\n\nPor otro lado, **`|`** selecciona elementos que cumplan **al menos una de las condiciones**. Esto significa que un elemento será seleccionado si cumple la primera condición, la segunda, o ambas.\n\nSi quisieras seleccionar elementos que sean menores que 5 **o** mayores que 10, usarías `|`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar elementos menores que 10 o mayores que 5\nmi_vector[mi_vector < 10 | mi_vector > 10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  3  9 12\n```\n\n\n:::\n:::\n\n\n\n\n\nUna forma sencilla de recordar esto:\\\n- **`&` (y lógico):** Solo selecciona valores cuando **todas** las condiciones son verdaderas.\\\n- **`|` (o lógico):** Selecciona valores cuando **cualquiera** de las condiciones es verdadera.\n\nCuando trabajas con vectores **nombrados**, puedes seleccionar elementos directamente usando sus nombres. Primero, debes asignar nombres a los elementos del vector. Esto se puede hacer al momento de crearlo o utilizando la función `names()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Crear un vector con nombres\nnames(mi_vector) = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\n```\n:::\n\n\n\n\n\nUna vez que los elementos tienen nombres, puedes acceder a ellos indicando el nombre entre comillas:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar un elemento por su nombre\nmi_vector[\"c\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc \n6 \n```\n\n\n:::\n:::\n\n\n\n\n\nTambién puedes seleccionar varios elementos utilizando un vector de nombres:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionar varios elementos por sus nombres\nmi_vector[c(\"b\", \"d\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nb d \n4 3 \n```\n\n\n:::\n:::\n\n\n\n\n\nLos nombres son especialmente útiles cuando los elementos tienen un significado asociado, ya que hacen que el código sea más fácil de leer y entender.\n\nPor último, debe saber también saber que puedes guardar los elementos seleccionados en un nuevo objeto para trabajar con ellos más adelante. Por ejemplo, si quisieras guardar todos los elementos mayores que 8 en un nuevo vector:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Guardar elementos mayores que 8 en un nuevo objeto\nvalores_altos <- mi_vector[mi_vector > 8]\n```\n:::\n\n\n\n\n\nDe manera similar, podrías guardar los elementos menores o iguales a 4 en otro vector:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Guardar elementos menores o iguales a 4 en un nuevo objeto\nvalores_bajos <- mi_vector[mi_vector <= 4]\n```\n:::\n\n\n\n\n\nAl almacenar los resultados en nuevos objetos, puedes realizar análisis posteriores o manipular solo una parte específica de tus datos sin alterar el vector original.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalores_altos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n e  f \n 9 12 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvalores_bajos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b d \n2 4 3 \n```\n\n\n:::\n:::\n\n\n\n\n\n## Flor y el análisis de datos electorales\n\nFlor decidió analizar los patrones de participación electoral en su región. Había encontrado un archivo con los porcentajes de participación de las últimas elecciones municipales y comenzó organizando su trabajo.\n\nLo primero que hizo Flor fue crear una carpeta en su computadora llamada \"Proyecto_Electoral\" y establecerla como su DIRECTORIO DE TRABAJO en RStudio. Esto aseguraba que todos los archivos y scripts se gestionaran de manera ordenada:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# setwd(\"C:/Usuarios/Flor/Documentos/Proyecto_Electoral\")\n```\n:::\n\n\n\n\n\nCon esta configuración, estaba lista para trabajar en su análisis.\n\nFlor sabía que los datos que manejaría en su análisis podían representarse mediante diferentes TIPOS DE ELEMENTOS en R. Decidió repasar estos conceptos creando algunos ejemplos:\n\n1.  **ELEMENTOS NUMÉRICOS**: Para almacenar valores continuos, como porcentajes de participación:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nporcentaje = 68.5\nclass(porcentaje)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\n\n2.  **ELEMENTOS DE TEXTO**: Para identificar las elecciones por su año:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neleccion = \"2012\"\nclass(eleccion)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n3.  **ELEMENTOS LÓGICOS**: Para indicar si la participación superaba el promedio:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalta_participacion = TRUE\nclass(alta_participacion)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\n\n\nSatisfecha con este repaso, Flor pasó a trabajar con TIPOS DE OBJETOS más complejos. Recopiló los porcentajes de participación de seis elecciones consecutivas y los almacenó en un VECTOR, que es un tipo de OBJETO que contiene ELEMENTOS del mismo tipo:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparticipacion = c(67.5, 74.6, 65.8, 78.3, 68.3, 66.7)\n```\n:::\n\n\n\n\n\nAl ser un VECTOR NUMÉRICO, podía realizar operaciones directamente sobre todos sus elementos. Calculó el promedio de participación con la función `mean()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npromedio = mean(participacion)\npromedio  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 70.2\n```\n\n\n:::\n:::\n\n\n\n\n\nPara hacer su VECTOR más legible, asignó nombres a los elementos, representando los años de las elecciones:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(participacion) = c(\"2012\", \"2014\", \"2016\", \"2018\", \"2020\", \"2022\")\nparticipacion\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2012 2014 2016 2018 2020 2022 \n67.5 74.6 65.8 78.3 68.3 66.7 \n```\n\n\n:::\n:::\n\n\n\n\n\nEsto resultó en un VECTOR nombrado, donde cada valor estaba asociado con su respectivo año. Luego, usó una OPERACIÓN LÓGICA para identificar las elecciones con participación superior al promedio. Esto devolvió un VECTOR LÓGICO, otro tipo de OBJETO que almacena ELEMENTOS `TRUE` o `FALSE`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# El elemento objeto fue nombrado previamente\nparticipacion > promedio \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n 2012  2014  2016  2018  2020  2022 \nFALSE  TRUE FALSE  TRUE FALSE FALSE \n```\n\n\n:::\n:::\n\n\n\n\n\nLuego, filtró los valores mayores al promedio utilizando esta condición:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparticipacion_alta = participacion[participacion > promedio]\nparticipacion_alta\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2014 2018 \n74.6 78.3 \n```\n\n\n:::\n:::\n\n\n\n\n\nDe esta manera, Flor creó un nuevo VECTOR que contenía solo los años con alta participación.\n\nFlor recordó que R tiene una gran cantidad de PAQUETES que extienden sus funcionalidades. Decidió usar el PAQUETE `psych` para obtener un resumen estadístico más detallado de su VECTOR de participación. Primero, instaló el PAQUETE:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"psych\")\n```\n:::\n\n\n\n\n\nLuego, lo cargó en su sesión de trabajo:\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\nCon la función `describe()` del PAQUETE `psych`, generó un resumen estadístico que incluía medidas como la media, la desviación estándar y los valores mínimo y máximo:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsych::describe(participacion)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   vars n mean   sd median trimmed  mad  min  max range skew kurtosis   se\nX1    1 6 70.2 5.05   67.9    70.2 2.45 65.8 78.3  12.5  0.6    -1.65 2.06\n```\n\n\n:::\n:::\n\n\n\n\n\nHablaremos con mayor detalle sobre `describe` y como podemos interpretar sus resultados en el capítulo 4.\n\n![Saber R te da poder](images/Ilustración_sin_título%201-2.png){fig-align=\"center\" width=\"443\"}\n\n## Resumen del capítulo\n\nR es un lenguaje de programación diseñado específicamente para el análisis estadístico y la creación de gráficos. Es gratuito, de código abierto, y cuenta con una comunidad activa que amplía continuamente sus capacidades. RStudio es el entorno donde se trabaja con R, organizando el código, los resultados y las herramientas en paneles funcionales: la **Fuente** para escribir y editar scripts, la **Consola** para ejecutar comandos, el **Entorno** para explorar objetos, y un panel adicional para gestionar gráficos, archivos y paquetes.\n\nLas funciones son bloques de código que realizan tareas específicas, como cálculos, transformación de datos o visualización gráfica. Por ejemplo, `sum()` calcula la suma de valores. Los paquetes en R son colecciones de funciones especializadas que amplían las capacidades del lenguaje. Para usarlos, primero deben instalarse con `install.packages()` y luego cargarse con `library()`.\n\nLos elementos en R representan datos básicos y están asociados a tipos como **numéricos** (para valores continuos), **enteros** (para conteos), **lógicos** (TRUE o FALSE), y **caracteres** (texto). Estos tipos se relacionan con variables estadísticas, como valores continuos o categorías. Los elementos lógicos se usan para realizar comparaciones, y los numéricos permiten operaciones matemáticas básicas,.\n\nLos objetos en R son estructuras que almacenan datos y facilitan su organización. Los principales tipos son: **vectores** (secuencia de elementos del mismo tipo), **matrices** (estructuras tabulares del mismo tipo), **listas** (colecciones heterogéneas), **factores** (categorías), y **data frames** (estructuras tabulares donde cada columna puede almacenar diferentes tipos de elementos).\n\nLos vectores son el tipo de objeto más básico en R y contienen elementos del mismo tipo. Se pueden realizar operaciones matemáticas o estadísticas directamente sobre ellos.También es posible filtrar elementos con índices o condiciones lógicas,\n\n## Ejercicios\n\n**1. En RStudio, puedes escribir código tanto en el script como en la consola. ¿Cuál es la principal diferencia entre estos dos lugares?**\\\n\na\\) El código escrito en el script se guarda para futuras referencias, mientras que el de la consola no se guarda automáticamente\\\nb) El script permite ejecutar múltiples líneas de código, mientras que la consola solo ejecuta una línea a la vez\\\nc) La consola es solo para pruebas rápidas y no permite editar el código como el script\\\nd) Todas las anteriores\n\n**2. ¿Qué pasos debes seguir para instalar y luego cargar el paquete `dplyr` en R?**\\\n\na\\) Ejecutar las funciones `install.packages(\"dplyr\")` y luego `library(dplyr)` en ese orden\\\nb) Escribir `install.packages(\"dplyr\")` y luego automáticamente el paquete estará disponible en la sesión\\\nc) Solo ejecutar `library(dplyr)` si ya tienes el paquete instalado previamente\\\nd) Instalar el paquete una sola vez y luego no necesitas cargarlo manualmente nunca más\n\n**3. Tienes el siguiente vector en R:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_vector = c(3, 6, 9, 12)\n```\n:::\n\n\n\n\n\n**¿Qué operación correctamente suma 5 a cada elemento del vector?**\\\n\na\\) `sum(mi_vector + 5)`\\\nb) `mi_vector + 5`\\\nc) `mi_vector[mi_vector + 5]`\\\nd) `mi_vector <- 5 + mi_vector`\n\n**4. ¿Qué tipo de datos representan los siguientes valores en R?**\\\n\n\\- **TRUE/FALSE**\\\n- **12.5, 4.3, 0.8**\\\n- **\"Rojo\", \"Azul\", \"Verde\"**\n\na)  Lógico; Numérico; Carácter\\\nb)  Ordinal; Continuo; Nominal\\\nc)  Lógico; Continuo; Texto\\\nd)  Entero; Lógico; Nominal\n\n**5. Dado el siguiente vector:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalores = c(2, 4, 6, 8, 10)\n```\n:::\n\n\n\n\n\n**¿Qué código devuelve únicamente los elementos mayores a 6?**\\\n\na\\) `valores[valores > 6]`\\\nb) `subset(valores > 6)`\\\nc) `valores[6]`\\\nd) `valores[valores < 6]`\n\n**6. ¿Qué comando te permite verificar el tipo de datos almacenado en un objeto en R?**\\\n\na\\) `describe()` b) `sum()`\\\nc) `mean()`\\\nd) `class()`\n\n**7. Un investigador trabaja con el siguiente objeto en R:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransporte <- c(\"Bus\", \"Taxi\", \"Bicicleta\", \"Bus\", \"Bicicleta\")\n```\n:::\n\n\n\n\n\n**¿Qué tipo de objeto es `transporte`?**\\\n\na\\) Matriz\\\nb) Vector\\\nc) Lista\\\nd) Data Frame\n\n**8. ¿Cuál de las siguientes opciones define correctamente este factor en R?**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(c(\"Alto\", \"Medio\", \"Bajo\"),\n       levels = c(\"Bajo\", \"Medio\", \"Alto\"),\n       ordered = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Alto  Medio Bajo \nLevels: Bajo < Medio < Alto\n```\n\n\n:::\n:::\n\n\n\n\n\na\\) Una variable nominal\n\nb). Un vector de caracteres\n\nc). Un vector lógico\n\nd). Una variable ordinal\n\n**9. Dado el siguiente vector:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumeros <- c(2, 4, 6, 8)\n```\n:::\n\n\n\n\n\n**¿Qué resultado devuelve la operación `numeros * 2 + 1`?**\\\na) Un vector con valores: 3, 5, 7, 9\\\nb) Un vector con valores: 5, 9, 13, 17\\\nc) Un vector con valores: 6, 9, 12, 15\\\nd) Un vector con valores: 4, 8, 12, 16\n\n**10. Supongamos que tienes el siguiente vector:**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_vector <- c(3, 6, 9, 12, 15, 18)\n```\n:::\n\n\n\n\n\n**¿Qué código selecciona correctamente los elementos que son mayores a 5 y menores a 15?**\\\n\na\\) `mi_vector[mi_vector > 5 | mi_vector < 15]`\n\nb\\) `mi_vector[mi_vector > 5 & mi_vector < 15]`\\\nc) `mi_vector[5 & 15]`\\\nd) `subset(mi_vector > 5 & mi_vector < 15)`\n",
    "supporting": [
      "fundamentosR_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}