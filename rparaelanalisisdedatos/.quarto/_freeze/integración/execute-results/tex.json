{
  "hash": "84dcdbacf5bc18409324676e2496bc63",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  warning: false\n  message: false\n---\n\n\n\n\n\n# Integración\n\n¿Cómo podemos usar R para analizar datos? En este capítulo, exploraremos los conceptos fundamentales que forman la base del análisis de datos en R, con un enfoque práctico en herramientas y procesos esenciales. Nuestro objetivo este capítulo será explicar la **importancia del manejo de datos** y cómo trabajar de manera eficiente con **`data.frames`** y **`tibbles`**.\n\nA lo largo del capítulo, nos centraremos en varios aspectos clave que forman parte del flujo de trabajo en el análisis de datos utilizando herramientas del tidyverse:\n\n-   **La importación de datos**: Aprenderemos a cargar datos desde diferentes fuentes, como archivos CSV o Excel, utilizando paquetes especializados.\n\n-   **La limpieza de datos**, donde aprenderemos a manejar problemas comunes como nombres de columnas inconsistentes, valores perdidos y duplicados, y cómo corregir tipos de datos incorrectos.\n\n-   **Las funciones resumen**, que nos permiten explorar rápidamente nuestros datos, identificar patrones y obtener información sobre su estructura y contenido.\n\n-   **La manipulación de datos con dplyr**, donde descubriremos cómo filtrar, seleccionar, agrupar y transformar datos con funciones diseñadas para ser intuitivas y fáciles de combinar.\n\n-   **La creación de visualizaciones con ggplot2**, donde aprenderemos a generar gráficos apropiados que no solo nos ayuden a explorar nuestros datos, sino que también comunican hallazgos de manera visual.\n\nEste capítulo es extenso, ya que cubre una amplia gama de conceptos fundamentales que se usarán a lo largo del resto del libro. Sin embargo, cada sección está diseñada para ser progresiva, conectando cada paso con el siguiente. Te animo a avanzar paso a paso, ya que cada etapa es fundamental es clave para poder entender el resto del contenido teórico del libro.\n\n## Data.frames\n\nCuando recolectamos o hacemos uso de conjuntos de datos, estos suelen estar almacenados en **estructuras tabulares**, lo que facilita su comprensión y análisis. Una **estructura tabular** se refiere a una organización de los datos donde cada columna representa una **variable** (es decir, una característica o atributo que estamos observando), y cada fila corresponde a una **observación** (un registro individual de los datos, como un caso o instancia). En R, la forma más común de trabajar con este tipo de estructuras es a través de **objetos denominados** `data.frames`.\n\n![Elaboración propia](images/Observación-01.png)\n\nRecuerda que, en el capítulo anterior, cuando exploramos los tipos de objetos en R, vimos que, a diferencia de una matriz (que también tiene una forma tabular pero almacena datos de un solo tipo), un `data.frame` permite que cada columna contenga datos de diferentes tipos. Esto significa que podemos trabajar simultáneamente con variables numéricas, categóricas o lógicas dentro de una misma estructura.\n\nImaginemos que queremos crear un conjunto de datos con tres variables:\\\n- **Edad**: numérica, que representa la edad de los encuestados.\\\n- **Género**: categórica, con valores como \"Masculino\" y \"Femenino\".\\\n- **Medio de comunicación preferido**: categórica, con valores como \"Televisión\", \"Radio\", \"Internet\" y \"Prensa Escrita\".\n\nPodemos construir este `data.frame` en R utilizando vectores para cada variable y luego combinándolos:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Crea vectores para cada variable\nedad = c(25, 30, 35, 40, 28)\ngenero = c(\"Femenino\", \"Masculino\", \"Femenino\", \n           \"Masculino\", \"Femenino\")\nmedio_comunicacion = c(\"Internet\", \"Televisión\", \"Radio\", \n                        \"Prensa Escrita\", \"Internet\")\n\n# Combina los vectores en un data.frame\nencuesta = data.frame(Edad = edad, \n                       Género = genero, \n                       Medio_de_comunicación_preferido = medio_comunicacion)\n```\n:::\n\n\n\n\n\nEl resultado es una tabla que muestra la edad, el género y medio de comunicación preferidos de los encuestados, estructurados en filas y columnas.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nencuesta\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Edad    Género Medio_de_comunicación_preferido\n1   25  Femenino                        Internet\n2   30 Masculino                      Televisión\n3   35  Femenino                           Radio\n4   40 Masculino                  Prensa Escrita\n5   28  Femenino                        Internet\n```\n\n\n:::\n:::\n\n\n\n\n\nAdemás, peudes seleccionar una columna de `data.frame` de forma individual utilizando el signo `$`\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nencuesta$Medio_de_comunicación_preferido\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Internet\"       \"Televisión\"     \"Radio\"          \"Prensa Escrita\"\n[5] \"Internet\"      \n```\n\n\n:::\n:::\n\n\n\n\n\nPara observar el data.frame de manera visual, RStudio ofrece herramientas muy convenientes. Podemos localizar el nombre del **data.frame** en el panel \"Entorno\" (Environment) y hacer clic en el ícono de la tabla que aparece al lado. Esto abrirá una vista interactiva en forma de hoja de cálculo, donde podrás explorar las filas y columnas de tu conjunto de datos.\n\n![](images/Observación-6.png)\n\nOtra forma, desde la consola, es usar la función `View()`. Por ejemplo, si tu **data.frame** se llama `encuesta`, simplemente escribe el siguiente código en la consola:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# View(encuesta)\n```\n:::\n\n\n\n\n\nAunque esta es una forma de generar un **data.frame**, es importante mencionar que, en la práctica, la mayoría de los conjuntos de datos no se crean desde cero. Normalmente, los datos provienen de otras fuentes, como archivos de texto, hojas de cálculo o bases de datos. Por ello, uno de los pasos más importantes al trabajar con datos es **importarlos desde estas fuentes**, lo cual veremos en más detalle más adelante.\n\n## El flujo de trabajo en el Tidyverse\n\nComo vimos en el anterior capítulo, un paquete en R es una colección de funciones y datos que extienden las capacidades básicas del lenguaje. Los paquetes te permiten realizar tareas específicas de manera más eficiente. Al instalar y cargar un paquete, se accede a un conjunto de herramientas especializadas que simplifican tu trabajo.\n\nDebido a que existe una multitud enorme de paquetes, sugiero les eches un vistazo siempre que puedas. Debido al propósito de este libro, nos centraremos especialmente en uno de estos que, a nivel personal, es muy intuitivo y poderoso: **El Tidyverse**. [@tidyverse-2]\n\nEl tidyverse es un sistema coherente de paquetes para la manipulación, exploración y visualización de datos que comparten una lógica de diseño común. Estos paquetes son fundamentales en el flujo de trabajo de un analista de datos y, en mi opinión personal, son algunos de los más comprensibles e intuitivos que existen en el mundo de la programación.\n\nAlgunas características del tidyverse:\n\n-   Todos los paquetes del tidyverse siguen principios de diseño similares y se entienden entre sí.\n\n-   La sintaxis y las funciones están diseñadas para ser fáciles de entender y usar.\n\n[![Extraído de teachdatascience.com](images/clipboard-3030342419.png){width=\"560\"}](https://teachdatascience.com/)\n\nLa imagen ilustra el flujo de trabajo típico al analizar datos usando los paquetes del **tidyverse**. Recuerda que debemos seguir un orden, pues esto asegura que podamos manejar nuestros datos de manera **coherente**, **reproducible** y **eficiente**.\n\nEl flujo de trabajo incluye las siguientes etapas principales:\n\n## Importación y resumen\n\nEl primer paso en el flujo de trabajo es **importar los datos desde fuentes externas** al entorno de R. En las ciencias sociales, los investigadores suelen trabajar con bases de datos provenientes de encuestas, experimentos o datos recolectados en plataformas como hojas de cálculo de Excel, herramientas de encuestas en línea o programas de análisis estadístico como SPSS o Stata. Aunque R incluye funciones base (viene por defecto y no necesitan cargar algún paquete) para la importación de datos, como `read.csv()`, en este capítulo nos enfocaremos en los paquetes especializados como **`readr`**, **`readxl`** y **`haven`**, que son más actuales y generan **`tibbles`**, una versión mejorada de los `data.frames`.\n\nUn ejemplo interesante es el caso de la **Encuesta Nacional de Hogares (Enaho)**, cuyos datos son publicados por las instituciones encargadas en diferentes formatos: **CSV**, **Stata (.dta)** y **SPSS (.sav)**. Esto demuestra cómo una misma base de datos puede estar disponible en múltiples formatos para adaptarse a las herramientas utilizadas por distintos analistas. Por ejemplo, un investigador que utiliza Excel podría optar por trabajar con el formato CSV, mientras que alguien que trabaja con Stata o SPSS puede preferir los archivos nativos de esos programas.\n\n### Importación\n\nLos archivos que utilizaremos a lo largo de este libro están disponibles en la **carpeta de archivos del libro**, la cual se recomienda descargar y guardar en una **carpeta de trabajo** en tu computadora. Para seguir los ejemplos en este capítulo, asegúrate de tener los archivos en tu carpeta de trabajo y configurar tu directorio de trabajo en RStudio.\n\nEl formato **CSV** (Comma-Separated Values) es uno de los más utilizados debido a su simplicidad y compatibilidad. Cada fila en un archivo CSV representa una observación, y los valores dentro de cada fila están separados por comas.\n\nUn ejemplo de cómo podría lucir un archivo CSV:\n\n```         \nID,Edad,Género,Ingreso\n1,25,Femenino,1500\n2,30,Masculino,2000\n3,45,Femenino,2500\n```\n\nEl paquete **`readr`** es parte del tidyverse y está diseñado para leer archivos CSV.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargamos el paquete readr\nlibrary(readr)\n```\n:::\n\n\n\n\n\nAl importar un conjunto de datos debemos nombrarlo.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importamos el archivo CSV y lo asignamos a un objeto\nencuesta_csv = read_csv(\"encuesta.csv\")\n\n# Mostramos\nencuesta_csv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 3\n  genero    medio_comunicación  edad\n  <chr>     <chr>              <dbl>\n1 Masculino Televisión            34\n2 Femenino  Redes sociales        25\n3 Femenino  Redes sociales        55\n4 Otro      Radio                 63\n5 Femenino  Televisión            47\n6 Masculino Redes sociales        19\n7 Masculino Redes sociales        29\n8 Masculino Periódico             75\n```\n\n\n:::\n:::\n\n\n\n\n\nLos archivos de Excel son comunes en las ciencias sociales debido a su facilidad de uso y capacidad para almacenar datos tabulares en varias hojas. El paquete **`readxl`** [@readxl] permite importar estos archivos, ya sea en formato `.xls` o `.xlsx`, sin necesidad de tener Excel instalado.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargamos el paquete readxl\nlibrary(readxl)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importamos los datos desde un archivo Excel\nencuesta_excel = read_excel(\"encuesta.xlsx\")\n\n# Mostramos \nencuesta_excel\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 3\n   genero    medio_comunicación  edad\n   <chr>     <chr>              <dbl>\n 1 Masculino Televisión            34\n 2 Femenino  Redes sociales        NA\n 3 Femenino  Redes sociales        55\n 4 Otro      Radio                 63\n 5 Femenino  Televisión            NA\n 6 Masculino Redes sociales        19\n 7 Masculino <NA>                  29\n 8 Masculino Periódico             75\n 9 Femenino  Redes sociales        55\n10 Masculino Televisión            34\n```\n\n\n:::\n:::\n\n\n\n\n\nSi el archivo contiene múltiples hojas, podemos especificar cuál importar utilizando el argumento `sheet`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importamos una hoja específica del archivo Excel\n# encuesta_excel_hoja = read_excel(\"encuesta.xlsx\", \n#                                  sheet = \"Resultados\")\n```\n:::\n\n\n\n\n\nEn ciencias sociales es común trabajar con datos provenientes de software estadístico como Stata o SPSS. Estos formatos incluyen información adicional, como etiquetas de variables, que son importantes para interpretar los datos correctamente. Para trabajar con estos archivos en R, utilizamos el paquete **`haven`** [@haven].\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargamos el paquete haven\nlibrary(haven)\n```\n:::\n\n\n\n\n\nImportamos un archivo Stata y lo asignamos a un objeto\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nencuesta_stata = read_dta(\"encuesta.dta\")\n\n# Mostramos \nencuesta_stata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n   Edad Género    Medio_de_comunicación_preferido\n  <dbl> <chr>     <chr>                          \n1    25 Femenino  Internet                       \n2    30 Masculino Televisión                     \n3    35 Femenino  Radio                          \n4    40 Masculino Prensa Escrita                 \n5    28 Femenino  Internet                       \n```\n\n\n:::\n:::\n\n\n\n\n\nO un archivo SPSS\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nencuesta_spss = read_sav(\"encuesta.sav\")\n\n# Mostramos\nencuesta_spss\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 3\n  genero    medio_comunicación  edad\n  <chr>     <chr>              <dbl>\n1 Masculino Televisión            34\n2 Femenino  Redes sociales        25\n3 Femenino  Redes sociales        55\n4 Otro      Radio                 63\n5 Femenino  Televisión            47\n6 Masculino Redes sociales        19\n7 Masculino Redes sociales        29\n8 Masculino Periódico             75\n```\n\n\n:::\n:::\n\n\n\n\n\n### Funciones resumen\n\nUna vez que hemos importado los datos a R, es fundamental conocer su estructura y contenido antes de proceder con el análisis. Para ello, podemos utilizar una variedad de **funciones resumen** que nos permiten explorar el tibble y obtener información importante sobre las variables y los datos contenidos allí.\n\n**`str()`** es una función base que describe la estructura del objeto, incluyendo el número de observaciones, las variables y sus tipos. Es muy parecida a `glimpse()` con la diferencia que es una función base y por lo tanto no depende del ecosistema tidyverse.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Información estructural básica del tibble\nstr(encuesta_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nspc_tbl_ [8 x 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ genero            : chr [1:8] \"Masculino\" \"Femenino\" \"Femenino\" \"Otro\" ...\n $ medio_comunicación: chr [1:8] \"Televisión\" \"Redes sociales\" \"Redes sociales\" \"Radio\" ...\n $ edad              : num [1:8] 34 25 55 63 47 19 29 75\n - attr(*, \"spec\")=\n  .. cols(\n  ..   genero = col_character(),\n  ..   medio_comunicación = col_character(),\n  ..   edad = col_double()\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n\n\n:::\n:::\n\n\n\n\n\n**`glimpse()`** es una función del tidyverse que proporciona una vista compacta del tibble, mostrando los nombres de las variables, sus tipos de datos y una muestra de valores.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargamos el paquete tibble\nlibrary(tibble)\n# Exploramos la estructura general del tibble\nglimpse(encuesta_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 8\nColumns: 3\n$ genero             <chr> \"Masculino\", \"Femenino\", \"Femenino\", \"Otro\", \"Femen~\n$ medio_comunicación <chr> \"Televisión\", \"Redes sociales\", \"Redes sociales\", \"~\n$ edad               <dbl> 34, 25, 55, 63, 47, 19, 29, 75\n```\n\n\n:::\n:::\n\n\n\n\n\n**`summary()`** proporciona estadísticas descriptivas básicas para cada columna, como mínimos, máximos, medias, medianas y conteos de valores para variables categóricas. De especial utilidad para el próximo capítulo.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Resumen estadístico de las variables\nsummary(encuesta_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    genero          medio_comunicación      edad      \n Length:8           Length:8           Min.   :19.00  \n Class :character   Class :character   1st Qu.:28.00  \n Mode  :character   Mode  :character   Median :40.50  \n                                       Mean   :43.38  \n                                       3rd Qu.:57.00  \n                                       Max.   :75.00  \n```\n\n\n:::\n:::\n\n\n\n\n\n**`head()`** muestra las primeras filas del tibble, permitiendo observar una muestra inicial de los datos. Puedes indicar cuanto valores deseas que devuelva especificando el segundo argumento, por defecto son seis.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualizamos las primeras seis filas\nhead(encuesta_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 3\n  genero    medio_comunicación  edad\n  <chr>     <chr>              <dbl>\n1 Masculino Televisión            34\n2 Femenino  Redes sociales        25\n3 Femenino  Redes sociales        55\n4 Otro      Radio                 63\n5 Femenino  Televisión            47\n6 Masculino Redes sociales        19\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualizamos las primeras dos filas\nhead(encuesta_csv, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 3\n  genero    medio_comunicación  edad\n  <chr>     <chr>              <dbl>\n1 Masculino Televisión            34\n2 Femenino  Redes sociales        25\n```\n\n\n:::\n:::\n\n\n\n\n\n**`tail()`** es similar a `head()`, pero muestra las últimas filas del tibble.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualizamos las últimas seis filas\ntail(encuesta_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 3\n  genero    medio_comunicación  edad\n  <chr>     <chr>              <dbl>\n1 Femenino  Redes sociales        55\n2 Otro      Radio                 63\n3 Femenino  Televisión            47\n4 Masculino Redes sociales        19\n5 Masculino Redes sociales        29\n6 Masculino Periódico             75\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualizamos las últimas dos filas\ntail(encuesta_csv, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 3\n  genero    medio_comunicación  edad\n  <chr>     <chr>              <dbl>\n1 Masculino Redes sociales        29\n2 Masculino Periódico             75\n```\n\n\n:::\n:::\n\n\n\n\n\n**`dim()`** devuelve las dimensiones del tibble, es decir, el número total de filas y columnas.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Verificamos las dimensiones del tibble\ndim(encuesta_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8 3\n```\n\n\n:::\n:::\n\n\n\n\n\n**`colnames()`** muestra los nombres de las columnas (variables) del tibble\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Consultamos los nombres de las columnas\ncolnames(encuesta_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"genero\"             \"medio_comunicación\" \"edad\"              \n```\n\n\n:::\n:::\n\n\n\n\n\nPerfecto, ya tenemos el primer paso cubierto. Manos a la obra.\n\n## Limpieza\n\nUna vez que hemos importado los datos, el siguientepaso es **limpiarlos**. Este proceso consiste en identificar y corregir problemas comunes como valores faltantes, nombres de columnas inconsistentes, duplicados y tipos de datos incorrectos. La limpieza asegura que los datos estén en un estado coherente y listo para ser transformado o analizado.\n\n![Extraído de: https://www.teraflow.ai/3-big-benefits-of-data-cleansing/](images/clipboard-3973043610.png){width=\"455\"}\n\n**Manejo de valores faltantes**\n\nEl **manejo de valores faltantes** es uno de los aspectos más complejos en la limpieza de datos, y un tema importante a considerar al trabajar con conjuntos de datos. Un **valor perdido** o **NA** en R no es lo mismo que un **0** o un espacio vacío. Un valor perdido (o **NA**, que significa \"Not Available\") es una celda que no contiene información en absoluto, lo que puede ocurrir por diversas razones, como un error en la recolección de los datos, una respuesta no proporcionada en una encuesta o una omisión involuntaria al momento de ingresar los datos. Por ejemplo:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nencuesta_excel\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 3\n   genero    medio_comunicación  edad\n   <chr>     <chr>              <dbl>\n 1 Masculino Televisión            34\n 2 Femenino  Redes sociales        NA\n 3 Femenino  Redes sociales        55\n 4 Otro      Radio                 63\n 5 Femenino  Televisión            NA\n 6 Masculino Redes sociales        19\n 7 Masculino <NA>                  29\n 8 Masculino Periódico             75\n 9 Femenino  Redes sociales        55\n10 Masculino Televisión            34\n```\n\n\n:::\n:::\n\n\n\n\n\nEn R, puedes detectar estos valores con funciones como `is.na()`, que devuelve un valor lógico (TRUE o FALSE) indicando si un valor es NA. Seleccionamos la columna.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(encuesta_excel$edad)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\nRecuerda que puedes sumar un vector lógico para contar los TRUE. En este caso los valores perdidos.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cantidad de valores perdidos \nsum(is.na(encuesta_excel$edad)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\nUna de las formas más simples de manejar valores faltantes es eliminarlos por completo. Esto puede hacerse utilizando la función `drop_na()` del paquete **tidyr** [@tidyr], que elimina las filas que contienen al menos un valor NA en cualquier columna. Esta es una solución rápida, pero es importante ser cauteloso, ya que puede resultar en la pérdida de información valiosa si hay muchos datos faltantes.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargamos tidyr\nlibrary(tidyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Eliminamos filas con valores faltantes\ndrop_na(encuesta_excel)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 x 3\n  genero    medio_comunicación  edad\n  <chr>     <chr>              <dbl>\n1 Masculino Televisión            34\n2 Femenino  Redes sociales        55\n3 Otro      Radio                 63\n4 Masculino Redes sociales        19\n5 Masculino Periódico             75\n6 Femenino  Redes sociales        55\n7 Masculino Televisión            34\n```\n\n\n:::\n:::\n\n\n\n\n\nComparemos\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Podemos nombrarlo\nencuesta_sin_na = drop_na(encuesta_excel)\n\n# Presta atención a las dimensiones del tibble original y del tibble sin NA\ndim(encuesta_excel)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  3\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(encuesta_sin_na)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7 3\n```\n\n\n:::\n:::\n\n\n\n\n\nSi queremos ser más específicos y eliminar valores faltantes solo en una columna particular, podemos usar:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Eliminamos filas donde la columna 'edad' tiene NA\nencuesta_sin_na = drop_na(encuesta_excel, edad)\n\nencuesta_sin_na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 3\n  genero    medio_comunicación  edad\n  <chr>     <chr>              <dbl>\n1 Masculino Televisión            34\n2 Femenino  Redes sociales        55\n3 Otro      Radio                 63\n4 Masculino Redes sociales        19\n5 Masculino <NA>                  29\n6 Masculino Periódico             75\n7 Femenino  Redes sociales        55\n8 Masculino Televisión            34\n```\n\n\n:::\n:::\n\n\n\n\n\nAunque eliminar valores faltantes puede ser un enfoque válido en algunos casos, no siempre es ideal. Si eliminamos demasiadas filas, podemos perder una cantidad significativa de información, lo que podría alterar los resultados de nuestro análisis. Por eso, en lugar de eliminar, muchas veces es preferible **imputar** los valores faltantes, es decir, reemplazarlos con un valor estimado. Por ejemplo, algunas estrategias comunes para imputar valores incluyen **reemplazar por el promedio** en el caso de variables numéricas o **reemplazar por la moda** en variables categóricas donde los valores faltantes pueden ser reemplazados por el valor más frecuente (la moda).\n\nPara las siguentes técnicas de limpieza utilizaremos el conjunto de datos `encuesta_problematica`. Te animo a que puedas identificar que posible problemas tiene antes de seguir adelante.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_problema = read.csv('encuesta_problematica.csv')\n\ndatos_problema\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID Nombre.PARTICIPANTE EDAD..años. Ingreso.Mensual género\n1  1         Luis Bartra          23          1500.0      F\n2  2        Carlos Gómez          27          2000.0      M\n3  3      Cristina Pérez          23          1500.0      F\n4  4         María López          45          2500.0      F\n5  5       Javier Muller          35          3800.0      M\n6  6          Liz García          29          1800.5      M\n```\n\n\n:::\n:::\n\n\n\n\n\nSi te diste cuenta, utilizamos **`read.csv`** en lugar de **`read_csv`** del paquete **readr**, ya que **`read_csv`** detecta automáticamente el tipo de dato de cada columna, incluso si hay errores en los valores. Para el propósito de este ejemplo, donde queremos ilustrar y solucionar errores comunes en los datos, no lo utilizaremos. ¡Pero ahí tienes otra gran razón para preferir **`read_csv`** en tu flujo de trabajo diario!\n\n**Estandarización de nombres de columnas**\n\nLos nombres de las columnas en los conjuntos de datos pueden ser inconsistentes, incluir caracteres especiales o espacios que dificulten el manejo en R.\n\nPrimero, identificamos los nombres originales del conjunto de datos utilizando la función base `names()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(datos_problema)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ID\"                  \"Nombre.PARTICIPANTE\" \"EDAD..años.\"        \n[4] \"Ingreso.Mensual\"     \"género\"             \n```\n\n\n:::\n:::\n\n\n\n\n\nPara resolver esto, utilizamos la función **`clean_names()`** del paquete **janitor**. Esta función transforma automáticamente los nombres de las columnas en un formato limpio y consistente:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargar el paquete janitor\nlibrary(janitor)\n\n# Estandarizar los nombres de las columnas\ndatos_problema = clean_names(datos_problema)\n```\n:::\n\n\n\n\n\nMostramos\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(datos_problema)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"id\"                  \"nombre_participante\" \"edad_anos\"          \n[4] \"ingreso_mensual\"     \"genero\"             \n```\n\n\n:::\n:::\n\n\n\n\n\n**Eliminación de duplicados**\n\nEn algunos casos, los datos pueden contener filas duplicadas que distorsionan el análisis. Podemos identificar y eliminar estas filas utilizando la función `distinct()` de `dplyr`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargamos dplyr\nlibrary(dplyr)\n\n# Eliminamos filas duplicadas\ndatos_problema = distinct(datos_problema)\n```\n:::\n\n\n\n\n\nMostramos\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_problema\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id nombre_participante edad_anos ingreso_mensual genero\n1  1         Luis Bartra        23          1500.0      F\n2  2        Carlos Gómez        27          2000.0      M\n3  3      Cristina Pérez        23          1500.0      F\n4  4         María López        45          2500.0      F\n5  5       Javier Muller        35          3800.0      M\n6  6          Liz García        29          1800.5      M\n```\n\n\n:::\n:::\n\n\n\n\n\nPara lo siguientes pasos vamos a utilizar como ejemplo el conjunto de datos **gapminder**. Este conjuto de datos contiene información sobre indicadores socioeconómicos de varios países a lo largo del tiempo. Incluye variables como la esperanza de vida (`lifeExp`), el PIB per cápita (`gdpPercap`) y la población a través de los años.\n\nPuedes descargar el conjunto de datos de datos desde la Datáfora o en el siguiente enlace y guardarla en tu carpeta de trabajo: [gapminder.csv](https://github.com/kirenz/datasets/blob/master/gapminder.csv).\n\nDado que el archivo está en formato `.csv` (valores separados por comas), utilizaremos la función `read_csv()` del paquete `readr`, que forma parte del tidyverse, para leer los datos:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n\n# Importamos el archivo CSV\ngapminder = read_csv('gapminder.csv')\n\n# Mostramos las primeras filas del dataset\nhead(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 6\n  country     continent  year lifeExp      pop gdpPercap\n  <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n```\n\n\n:::\n:::\n\n\n\n\n\nOtra opción es instalar y cargar el paquete llamado `gapminder` [@gapminder], que contiene el mismo conjunto de datos:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargar el paquete\nlibrary(gapminder)\n\n# Mostramos las primeras filas del dataset\nhead(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 6\n  country     continent  year lifeExp      pop gdpPercap\n  <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n```\n\n\n:::\n:::\n\n\n\n\n\n## Manipulación\n\nUna vez limpios nuestros datos pasamos al tercer paso: la manipulación de datos. La manipulación de datos consiste en transformar y preparar los datos para su análisis, lo que puede incluir la creación de nuevas variables, el filtrado de observaciones o la omisión de alguna variable. Para ello, usaremos el paquete `dplyr` [@dplyr] del tidyverse.\n\n`dplyr` es un paquete del tidyverse diseñado específicamente para la manipulación de datos. Proporciona un conjunto de funciones que permiten seleccionar, filtrar, ordenar, resumir y transformar datos en data.frames. Una de las características más importantes de dplyr es su uso del \"pipe operator\" (`%>%`), que permite encadenar múltiples operaciones de manera secuencial, pasando el resultado de una función directamente como entrada a la siguiente. Esto hace que el código sea más fácil de leer y mantener.\n\nEl atajo del teclado para el pipe operator (`%>%`) es:\n\n-   Ctrl + Shift + M (Windows)\n\n-   Cmd + Shift + M (Mac)\n\n**Un sistema de tuberías**\n\nPara poder realizar múltiples acciones en secuencia conectando cada acción con la siguiente a través de \"tuberías\" debemos utilizar lo que se llama el *pipe operator* (`%>%`).\n\n![](images/clipboard-3784925606.png)\n\nLo iremos viendo, de momento tienes que conocer algunas de las principales funciones de dplyr:\n\n-   `filter()`: Filtra filas de un dataframe según una condición específica.\n-   `select()`: Selecciona columnas específicas de un dataframe.\n-   `mutate()`: Crea nuevas columnas o modifica las existentes en un dataframe.\n-   `summarize()`: Resumen estadístico de las columnas de un dataframe.\n-   `arrange()`: Ordena las filas de un dataframe según una o más variables.\n-   `group_by()`: Agrupa un dataframe por una o más variables, preparándolo para operaciones de resumen.\n\nPara empezar a trabajar con `dplyr` recuerda primero cargarlo:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages('dplyr')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\n\n\n\nA continuación, verás que muchas de las funciones terminan con un comando `head()` , esto es únicamente para evitar mostrar todos los datos del data.frame por motivos puramente estéticos del libro.\n\n### Funciones principales\n\n**Filter()**\n\nLa función `filter()` nos ayuda a filtrar filas bajo una condición.\n\n![Elaboración propia](images/clipboard-1638975480.png)\n\nUtilizando el pipe operator (`%>%`) vamos a filtrar nuestros datos únicamente para aquellos que sean del 2007. Para ello nuestra condición sera que la variable `year` sea igual a 2007.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>% \n  # Filtramos las filas donde la variable year sea igual a 2007\n  filter(year == 2007) %>% \n  # Mostramos las primeras 5 filas del resultado para fines estéticos\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 6\n  country     continent  year lifeExp      pop gdpPercap\n  <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n1 Afghanistan Asia       2007    43.8 31889923      975.\n2 Albania     Europe     2007    76.4  3600523     5937.\n3 Algeria     Africa     2007    72.3 33333216     6223.\n4 Angola      Africa     2007    42.7 12420476     4797.\n5 Argentina   Americas   2007    75.3 40301927    12779.\n```\n\n\n:::\n:::\n\n\n\n\n\nPodemos asignarle un propio nombre\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_2007 = gapminder %>%\n  filter(year == 2007)\n```\n:::\n\n\n\n\n\nAhora tenemos otro `data.frame` filtrado solo por los valores que tenían como año el 2007. Podemos resumirlo de la misma forma.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(gapminder_2007)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nspc_tbl_ [142 x 6] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ country  : chr [1:142] \"Afghanistan\" \"Albania\" \"Algeria\" \"Angola\" ...\n $ continent: chr [1:142] \"Asia\" \"Europe\" \"Africa\" \"Africa\" ...\n $ year     : num [1:142] 2007 2007 2007 2007 2007 ...\n $ lifeExp  : num [1:142] 43.8 76.4 72.3 42.7 75.3 ...\n $ pop      : num [1:142] 31889923 3600523 33333216 12420476 40301927 ...\n $ gdpPercap: num [1:142] 975 5937 6223 4797 12779 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   country = col_character(),\n  ..   continent = col_character(),\n  ..   year = col_double(),\n  ..   lifeExp = col_double(),\n  ..   pop = col_double(),\n  ..   gdpPercap = col_double()\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n\n\n:::\n:::\n\n\n\n\n\nTambién podemos filtrar con más de una condición. Imaginemos que queremos saber los valores del 2002 del Perú\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>% \n  # Filtramos las filas donde year sea igual a 2002\n  filter(year == 2002, \n         # Y donde el país sea igual a 'Peru'\n         country == 'Peru')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 6\n  country continent  year lifeExp      pop gdpPercap\n  <chr>   <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n1 Peru    Americas   2002    69.9 26769436     5909.\n```\n\n\n:::\n:::\n\n\n\n\n\nO los países que al año 2007 tenían mas de 100 millones de habitantes.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>% \n  # Filtramos las filas donde year sea igual a 2007\n  filter(year == 2007, \n         # Y donde la población (pop) sea mayor a 100 millones\n         pop > 100000000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 6\n   country       continent  year lifeExp        pop gdpPercap\n   <chr>         <chr>     <dbl>   <dbl>      <dbl>     <dbl>\n 1 Bangladesh    Asia       2007    64.1  150448339     1391.\n 2 Brazil        Americas   2007    72.4  190010647     9066.\n 3 China         Asia       2007    73.0 1318683096     4959.\n 4 India         Asia       2007    64.7 1110396331     2452.\n 5 Indonesia     Asia       2007    70.6  223547000     3541.\n 6 Japan         Asia       2007    82.6  127467972    31656.\n 7 Mexico        Americas   2007    76.2  108700891    11978.\n 8 Nigeria       Africa     2007    46.9  135031164     2014.\n 9 Pakistan      Asia       2007    65.5  169270617     2606.\n10 United States Americas   2007    78.2  301139947    42952.\n```\n\n\n:::\n:::\n\n\n\n\n\n**Select()**\n\nUtilizamos la función `select()` para filtrar por las columnas que son de nuestro interés. Muchas veces vamos a querer seleccionar solo algunas para nuestro análisis.\n\n![](images/clipboard-4017595068.png)\n\nComo argumentos `select()` solo necesita el nombre de la columna de interés.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Seleccionamos solo las columnas country, year y pop\n  select(country, year, pop) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n  country      year      pop\n  <chr>       <dbl>    <dbl>\n1 Afghanistan  1952  8425333\n2 Afghanistan  1957  9240934\n3 Afghanistan  1962 10267083\n4 Afghanistan  1967 11537966\n5 Afghanistan  1972 13079460\n```\n\n\n:::\n:::\n\n\n\n\n\n**Arrange()**\n\nUtilizamos la función `arrange()` para poder ordenar las observaciones (filas) que tengamos.\n\n![](images/clipboard-3710368930.png)\n\nImagina que queremos ordenarlo por quien tenga la menor esperanza de vida.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Ordenamos las filas por la columna lifeExp en orden ascendente\n  arrange(lifeExp) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 6\n  country      continent  year lifeExp     pop gdpPercap\n  <chr>        <chr>     <dbl>   <dbl>   <dbl>     <dbl>\n1 Rwanda       Africa     1992    23.6 7290203      737.\n2 Afghanistan  Asia       1952    28.8 8425333      779.\n3 Gambia       Africa     1952    30    284320      485.\n4 Angola       Africa     1952    30.0 4232095     3521.\n5 Sierra Leone Africa     1952    30.3 2143249      880.\n```\n\n\n:::\n:::\n\n\n\n\n\nSi lo queremos de mayor a menor solo debemos que envolverlo en otra función llamada `desc()`\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Ordenamos las filas por la columna lifeExp en orden descendente\n  arrange(desc(lifeExp)) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 6\n  country          continent  year lifeExp       pop gdpPercap\n  <chr>            <chr>     <dbl>   <dbl>     <dbl>     <dbl>\n1 Japan            Asia       2007    82.6 127467972    31656.\n2 Hong Kong, China Asia       2007    82.2   6980412    39725.\n3 Japan            Asia       2002    82   127065841    28605.\n4 Iceland          Europe     2007    81.8    301931    36181.\n5 Switzerland      Europe     2007    81.7   7554661    37506.\n```\n\n\n:::\n:::\n\n\n\n\n\nEsto es fenomenal, pero si tomamos a todos los países en cualquier momento no tenemos una fotografía muy clara de los hechos. Quizás convendría mejor analizar los datos únicamente centrándonos en un año. Podemos filtrar los valores solo para el año 2007 con `filter()` y luego conectarlo con `arrange()` y `desc()` para ordenarlo de mayor a menor. Para concatenar acciones solo debemos conectarlas con el pipe operator (`%>%`)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Filtramos las filas donde year sea igual a 2007\n  filter(year == 2007) %>%\n  # Ordenamos las filas por la columna lifeExp en orden descendente\n  arrange(desc(lifeExp)) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 6\n  country          continent  year lifeExp       pop gdpPercap\n  <chr>            <chr>     <dbl>   <dbl>     <dbl>     <dbl>\n1 Japan            Asia       2007    82.6 127467972    31656.\n2 Hong Kong, China Asia       2007    82.2   6980412    39725.\n3 Iceland          Europe     2007    81.8    301931    36181.\n4 Switzerland      Europe     2007    81.7   7554661    37506.\n5 Australia        Oceania    2007    81.2  20434176    34435.\n```\n\n\n:::\n:::\n\n\n\n\n\n**Mutate()**\n\nUsamos la función `mutate()` para modificar columna existentes o crear nuevas.\n\n![](images/clipboard-1384461819.png)\n\nCrear una nueva columna con el Producto Interno Bruto (PIB)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Creamos una nueva columna llamada PIB_Bruto calculando gdpPercap * pop\n  mutate(PIB_Bruto = gdpPercap * pop) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 7\n  country     continent  year lifeExp      pop gdpPercap   PIB_Bruto\n  <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>       <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779. 6567086330.\n2 Afghanistan Asia       1957    30.3  9240934      821. 7585448670.\n3 Afghanistan Asia       1962    32.0 10267083      853. 8758855797.\n4 Afghanistan Asia       1967    34.0 11537966      836. 9648014150.\n5 Afghanistan Asia       1972    36.1 13079460      740. 9678553274.\n```\n\n\n:::\n:::\n\n\n\n\n\nCrear una nueva columna con el PIB en miles de millones:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Creamos una nueva columna llamada PBI_Mil_Millones \n  # dividiendo el PIB bruto entre mil millones\n  mutate(PBI_Mil_Millones = \n           (gdpPercap * pop) / 1000000000) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 7\n  country     continent  year lifeExp      pop gdpPercap PBI_Mil_Millones\n  <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>            <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.             6.57\n2 Afghanistan Asia       1957    30.3  9240934      821.             7.59\n3 Afghanistan Asia       1962    32.0 10267083      853.             8.76\n4 Afghanistan Asia       1967    34.0 11537966      836.             9.65\n5 Afghanistan Asia       1972    36.1 13079460      740.             9.68\n```\n\n\n:::\n:::\n\n\n\n\n\nTambién podemos utilizar `mutate()` para modificar una variable existente, sobreescribiéndola. Supongamos que queremos aumentar en un 10% el PBI per cápita de todos los países.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Modificamos la columna gdpPercap aumentando su valor en un 10%\n  mutate(gdpPercap = gdpPercap * 1.1) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 6\n  country     continent  year lifeExp      pop gdpPercap\n  <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      857.\n2 Afghanistan Asia       1957    30.3  9240934      903.\n3 Afghanistan Asia       1962    32.0 10267083      938.\n4 Afghanistan Asia       1967    34.0 11537966      920.\n5 Afghanistan Asia       1972    36.1 13079460      814.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(gapminder %>%\n       mutate(PBI_Mil_Millones = (gdpPercap * pop)/1000000000)\n  \n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 7\n  country     continent  year lifeExp      pop gdpPercap PBI_Mil_Millones\n  <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>            <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.             6.57\n2 Afghanistan Asia       1957    30.3  9240934      821.             7.59\n3 Afghanistan Asia       1962    32.0 10267083      853.             8.76\n4 Afghanistan Asia       1967    34.0 11537966      836.             9.65\n5 Afghanistan Asia       1972    36.1 13079460      740.             9.68\n6 Afghanistan Asia       1977    38.4 14880372      786.            11.7 \n```\n\n\n:::\n:::\n\n\n\n\n\nFinalmente, podemos concatenarlo con el resto de operaciones de la misa forma.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Seleccionamos solo las columnas de interés\n  select(country, year, pop, gdpPercap) %>%\n  # Filtramos las filas donde year sea igual a 2007\n  filter(year == 2007) %>%\n  # Ordenamos las filas por la columna gdpPercap en orden descendente\n  arrange(desc(gdpPercap)) %>%\n  # Creamos una nueva columna llamada PBI calculando gdpPercap * pop\n  mutate(PBI = (gdpPercap * pop)) %>%\n  # Mostramos las primeras 5 filas para facilitar la visualización\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 5\n  country        year       pop gdpPercap     PBI\n  <chr>         <dbl>     <dbl>     <dbl>   <dbl>\n1 Norway         2007   4627926    49357. 2.28e11\n2 Kuwait         2007   2505559    47307. 1.19e11\n3 Singapore      2007   4553009    47143. 2.15e11\n4 United States  2007 301139947    42952. 1.29e13\n5 Ireland        2007   4109086    40676. 1.67e11\n```\n\n\n:::\n:::\n\n\n\n\n\n**Summarise() / Reframe()**\n\nCuando queremos obtener estadísticas resumidas de una o más variables (por ejemplo, calcular promedios, totales o conteos) usamos funciones como `summarise()`. Esta nos permite condensar la información y obtener un nuevo dataframe con solo los valores que nos interesan. En versiones recientes de dplyr, te va a aparecer `reframe()` en su lugar: esto se debe a que el paquete está actualizando algunos nombres para que reflejen mejor lo que hacen. No te preocupes, lo esencial es lo siguiente: usa `summarise()` si quieres un resumen compacto, y `reframe()` si necesitas conservar más de una fila por grupo o mayor flexibilidad.\n\n![](images/clipboard-4262009664.png)\n\nSupongamos que queremos conocer la esperanza de vida media.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Calculamos la esperanza de vida media\n  summarise(espvida_media = mean(lifeExp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n  espvida_media\n          <dbl>\n1          59.5\n```\n\n\n:::\n:::\n\n\n\n\n\nPodemos calcular dos cosas a la vez. La esperanza de vida media y el total de la población\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Calculamos la esperanza de vida media y el total de la población\n  reframe(espvida_media = mean(lifeExp), popTotal = sum(pop))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 2\n  espvida_media    popTotal\n          <dbl>       <dbl>\n1          59.5 50440465801\n```\n\n\n:::\n:::\n\n\n\n\n\nIntentemos esta vez calcular la esperanza de vida media y el total de la población en América en 2002.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Filtramos las filas donde year sea igual a 2002\n  # y el continente sea \"Americas\"\n  filter(year == 2002, continent == \"Americas\") %>%\n  # Calculamos la esperanza de vida media y el total de la población\n  reframe(espvida_media = mean(lifeExp), popTotal = sum(pop))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 2\n  espvida_media  popTotal\n          <dbl>     <dbl>\n1          72.4 849772762\n```\n\n\n:::\n:::\n\n\n\n\n\nSin embargo, el verdadero poder de `reframe()` es cuando lo combinamos con la siguiente función.\n\n**Group_by()**\n\nSupongamos que queremos calcular la esperanza de vida y el total de la población de todos los países cada año. Para ello podríamos realizar el siguiente código\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Empezando por el primer año...\ngapminder %>%\n  filter(year == 1952) %>%\n  summarize(espvida_media = mean(lifeExp), popTotal = sum(pop))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 2\n  espvida_media   popTotal\n          <dbl>      <dbl>\n1          49.1 2406957150\n```\n\n\n:::\n:::\n\n\n\n\n\nLo tenemos para un año, pero si quisiéramos aplicarlo para **cada año** esto sería bastante tedioso y quereriría muchas líneas de código, sin contar con que el resultado estará en dataframes separados. Para esto la función `group_by()` entra en acción.\n\nLa función `group_by` le dice a dplyr que realice las operaciones por grupos en vez de aplicarlas a todo el datset a la vez.\n\n![](images/clipboard-3380744810.png)\n\nPara ello simplemente tenemos que especificar la variable a agrupar, en este caso, los años.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tomamos el conjunto de datos gapminder\ngapminder %>%\n  # Agrupamos los datos por la variable year\n  group_by(year) %>%\n  # Calculamos la esperanza de vida media y el total de la población por año\n  summarise(espvida_media = mean(lifeExp), popTotal = sum(pop))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 3\n    year espvida_media   popTotal\n   <dbl>         <dbl>      <dbl>\n 1  1952          49.1 2406957150\n 2  1957          51.5 2664404580\n 3  1962          53.6 2899782974\n 4  1967          55.7 3217478384\n 5  1972          57.6 3576977158\n 6  1977          59.6 3930045807\n 7  1982          61.5 4289436840\n 8  1987          63.2 4691477418\n 9  1992          64.2 5110710260\n10  1997          65.0 5515204472\n11  2002          65.7 5886977579\n12  2007          67.0 6251013179\n```\n\n\n:::\n:::\n\n\n\n\n\nY listo! El nuevo `data.frame` ahora muestra los datos para cada año en que se tomaron los datos.\n\n### Dplyr en acción\n\nAhora que hemos aprendido las funciones básicas de `dplyr`, vamos a ponerlas en práctica con ejemplos concretos.\n\n**Calcular la esperanza de vida media y el total de población de cada continente en el 2007, ordenado por mayor esperanza de vida**\n\nPodemos filtrar los datos para el año 2007, agruparlos por continente, calcular la esperanza de vida media y el total de población, y luego ordenar los resultados por esperanza de vida media en orden descendente.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>%\n# Filtramos los datos para el año 2007\n  filter(year == 2007) %>%  \n# Agrupamos los datos por continente\n  group_by(continent) %>% \n# Calculamos la esperanza de vida media y el total de población\n  summarise(espvida_media = mean(lifeExp), popTotal = sum(pop)) %>%  \n# Ordenamos los resultados por esperanza de vida media en orden descendente\n  arrange(desc(espvida_media))  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n  continent espvida_media   popTotal\n  <chr>             <dbl>      <dbl>\n1 Oceania            80.7   24549947\n2 Europe             77.6  586098529\n3 Americas           73.6  898871184\n4 Asia               70.7 3811953827\n5 Africa             54.8  929539692\n```\n\n\n:::\n:::\n\n\n\n\n\n**Crear una nueva columna con el PIB total (PIB per cápita \\* población) y filtrar los países con un PIB total mayor a 1 billón en 2007**\n\nVamos a crear una nueva columna para el PIB total, filtrar los datos para el año 2007, y luego seleccionar solo los países con un PIB total mayor a 1 billón.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>%\n# Creamos una nueva columna para el PIB total\n  mutate(PIB_Total = gdpPercap * pop) %>% \n# Filtramos los datos para el año 2007 y PIB total mayor a 1 billón\n  filter(year == 2007, PIB_Total > 1e12) %>% \n# Seleccionamos las columnas de interés\n  select(country, continent, PIB_Total) %>%  \n# Ordenamos los resultados por PIB total en orden descendente\n  arrange(desc(PIB_Total))  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 13 x 3\n   country        continent PIB_Total\n   <chr>          <chr>         <dbl>\n 1 United States  Americas    1.29e13\n 2 China          Asia        6.54e12\n 3 Japan          Asia        4.04e12\n 4 India          Asia        2.72e12\n 5 Germany        Europe      2.65e12\n 6 United Kingdom Europe      2.02e12\n 7 France         Europe      1.86e12\n 8 Brazil         Americas    1.72e12\n 9 Italy          Europe      1.66e12\n10 Mexico         Americas    1.30e12\n11 Canada         Americas    1.21e12\n12 Spain          Europe      1.17e12\n13 Korea, Rep.    Asia        1.15e12\n```\n\n\n:::\n:::\n\n\n\n\n\n**Calcular la esperanza de vida media y el total de población de cada continente a lo largo del tiempo**\n\nEn este ejemplo, queremos ver cómo ha cambiado la esperanza de vida media y la población total en cada continente a lo largo del tiempo.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creamos 'x'\nx = gapminder %>% \n# Agrupamos los datos por continente y año\n  group_by(continent, year) %>% \n# Calculamos la esperanza de vida media y el total de población\n  summarise(espvida_media = mean(lifeExp), popTotal = sum(pop)) %>% \n# Ordenamos los resultados por continente y año\n  arrange(continent, year)  \n# Seleccionamos únicamente los primeros 12 (África) por motivos estéticos\nhead(x, 12) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 4\n# Groups:   continent [1]\n   continent  year espvida_media  popTotal\n   <chr>     <dbl>         <dbl>     <dbl>\n 1 Africa     1952          39.1 237640501\n 2 Africa     1957          41.3 264837738\n 3 Africa     1962          43.3 296516865\n 4 Africa     1967          45.3 335289489\n 5 Africa     1972          47.5 379879541\n 6 Africa     1977          49.6 433061021\n 7 Africa     1982          51.6 499348587\n 8 Africa     1987          53.3 574834110\n 9 Africa     1992          53.6 659081517\n10 Africa     1997          53.6 743832984\n11 Africa     2002          53.3 833723916\n12 Africa     2007          54.8 929539692\n```\n\n\n:::\n:::\n\n\n\n\n\n**Comparar la esperanza de vida y el PIB per cápita entre dos países específicos (Perú y Chile) en 2007**\n\nVamos a filtrar los datos para los países Perú y Chile en el año 2007, y comparar la esperanza de vida y el PIB per cápita entre ellos.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>%\n# Filtramos los datos para Perú y Chile en el año 2007\n  filter(year == 2007, country %in% c(\"Peru\", \"Chile\")) %>%\n# Seleccionamos las columnas de interés\n  select(country, lifeExp, gdpPercap) %>%  \n# Ordenamos los resultados por país\n  arrange(country)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 3\n  country lifeExp gdpPercap\n  <chr>     <dbl>     <dbl>\n1 Chile      78.6    13172.\n2 Peru       71.4     7409.\n```\n\n\n:::\n:::\n\n\n\n\n\n**Crear una nueva columna con la relación PIB per cápita y esperanza de vida, y analizar esta relación para los países en Asia en 2007**\n\nPodemos crear una nueva columna para la relación entre PIB per cápita y esperanza de vida, y luego analizamos esta relación para los países en Asia en 2007.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = gapminder %>%\n# Filtramos los datos para los países en Asia en 2007\n  filter(year == 2007, continent == \"Asia\") %>%\n# Creamos una nueva columna para la relación PIB per cápita / esperanza de vida\n  mutate(PIB_vs_vida = gdpPercap / lifeExp) %>% \n# Seleccionamos las columnas de interés\n  select(country, PIB_vs_vida) %>% \n# Ordenamos los resultados por la relación PIB per cápita / esperanza de vida en orden descendente\n  arrange(desc(PIB_vs_vida))  \n\nhead(x, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 2\n   country          PIB_vs_vida\n   <chr>                  <dbl>\n 1 Kuwait                  610.\n 2 Singapore               589.\n 3 Hong Kong, China        483.\n 4 Bahrain                 394.\n 5 Japan                   383.\n 6 Taiwan                  366.\n 7 Israel                  316.\n 8 Saudi Arabia            298.\n 9 Korea, Rep.             297.\n10 Oman                    295.\n```\n\n\n:::\n:::\n\n\n\n\n\n## Visualización\n\nLa última etapa del flujo de trabajo es la **visualización de datos**. Poder visualizar la información no solo nos ayuda a a anticipar ciertos patrones y comportamientos, sino que también facilita la comunicación de estos hallazgos a otros. Es importante reconocer que tendemos a dejarnos llevar más por los gráficos que por los resúmenes numéricos, aunque ambos sean igualmente importantes.\n\n`ggplot2` es uno de los paquetes más populares y poderosos en R para la creación de gráficos. Para generar gráficos adecuados en R, necesitamos considerar dos elementos fundamentales: el elemento estadístico y el elemento de diseño. La finalidad de un gráfico es resumir y transmitir información de manera adecuada para el análisis que estamos realizando, sin olvidar la importancia de un diseño atractivo. `ggplot2` [@ggplot2] consigue ambos objetivos.\n\nAntes de empezar a usar `ggplot2`, necesitamos instalarlo y cargarlo. de R.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Instalación del paquete ggplot2 (en caso no esté instalado)\n#install.packages('ggplot2')\n\n# Carga del paquete ggplot2\nlibrary(ggplot2)\n```\n:::\n\n\n\n\n\n### Fundamentos de ggplot2\n\nLa creación de gráficos con `ggplot2` se basa en la gramática de los gráficos (Grammar of Graphics). Esta gramática define una serie de componentes que forman parte de un gráfico:\n\n1.  **Datos**: El conjunto de datos que queremos visualizar.\n2.  **Estética**: La asignación de variables a aspectos visuales del gráfico, como posición, color, tamaño, etc.\n3.  **Geometría**: El tipo de gráfico (barras, puntos, líneas, etc.).\n4.  **Facetas**: Subdivisiones del gráfico en múltiples paneles basados en una o más variables.\n5.  **Estadísticas**: Transformaciones estadísticas que se aplican a los datos antes de graficarlos.\n6.  **Coordenadas**: El sistema de coordenadas usado (cartesiano, polar, etc.).\n7.  **Tema**: Elementos de diseño y formato del gráfico.\n\nPiensa en cada uno de ellos como una capa que va encima. Para construir un gráfico en `ggplot2`, concatenamos diferentes capas usando el operador `+`. Cada capa añade un nuevo componente al gráfico.\n\n![Extraído de: https://cristoichkov.github.io](images/clipboard-1644515835.png)\n\nVamos a empezar con un gráfico de dispersión básico utilizando el conjunto de datos `gapminder`. Este conjunto contiene datos sobre el Producto Interno Bruto (PIB) per cápita, la esperanza de vida y otros indicadores para varios países a lo largo del tiempo.\n\nEmpezamos agregando la primera capa, los datos. Para comenzar, creamos la base del gráfico con la función `ggplot()`, y como argumento el conjunto de datos `gapminder`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder)\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-64-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nComo ves, los datos por si solos únicamente nos dan un recuadro blanco, debemos añadir el resto de capas. Definimos las estéticas del gráfico con la función `aes()`, asignando el PIB per cápita al eje x (`gdpPercap`) y la esperanza de vida al eje y (`lifeExp`).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp))\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-65-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nAhora que R sabe qué datos vamos a utilizar y qué variables tomar como coordenadas, necesitamos especificar qué tipo de gráfico queremos crear. En `ggplot2`, hay muchas `geoms` (geometrías), y cada una proporciona un tipo de gráfico diferente. Por ejemplo, `geom_bar` crea un gráfico de barras y `geom_line` crea un gráfico de líneas. En este caso, como ambas variables (PIB per cápita y esperanza de vida) son numéricas, usaremos un gráfico de dispersión (puntos) para visualizar la relación entre ellas. Para ello, usamos `geom_point()`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-66-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nEn este ejemplo, `aes(x = gdpPercap, y = lifeExp)` define la estética del gráfico, asignando el Producto Interno Bruto per cápita al eje x y la esperanza de vida al eje y. `geom_point()` especifica que queremos un gráfico de dispersión. Ya puedes lanzarte a sacar tus primeras conclusiones.\n\nAlgo que podemos notar es que el gráfico se ve un poco apretado al principio. Para mejorar la visualización, podemos usar una escala logarítmica en el eje x. Esto transforma los datos para que las diferencias entre los puntos se aprecien mejor, especialmente cuando algunos países tienen un PIB per cápita muy alto y otros muy bajo. Solo recuerda que usar una escala logarítmica cambia la manera en que interpretamos el gráfico, así que debemos tenerlo en cuenta.\n\nUsamos `scale_x_log10()` para transformar el eje x a una escala logarítmica.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point() +\n  scale_x_log10()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-67-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nEn este caso, hemos añadido `scale_x_log10()` para aplicar la escala logarítmica en el eje x. Esto clarifica la relación entre las variables, permitiéndonos observar que un mayor PIB per cápita generalmente se asocia con una mayor esperanza de vida.\n\nTambién podemos añadir otros elementos estéticos para mejorar la visualización, como el color de los puntos basado en el continente. Para ello, modificamos `aes()` para incluir `color = continent`, lo que añade color a los puntos según el continente. Recuerda que `continent` es una variable categórica del conjunto de datos.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder, aes(x = gdpPercap, \n                      y = lifeExp, \n                      color = continent)) +\n  geom_point() +\n  scale_x_log10()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-68-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nTe animo a que sigas intentando identificar patrones importantes. Por ejemplo, ¿dónde se encuentran los puntos asociados a determinados continentes? ¿Existe alguna relación entre el continente y las otras dos variables?\n\nEste gráfico ya es de por si sumamente útil pero si deseamos poder comunicarlo cada uno de los elementos deben estar debidamente nombrados. Para ello, es importante añadir etiquetas y títulos para mejorar la interpretación del gráfico. Esto lo podemos hacer agregando una capa más con la función `labs()` y usando como argumentos `title`, `x`, `y` y `color`.\n\nUsamos `labs()` para añadir un título y etiquetas a los ejes.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  scale_x_log10() +\n  labs(title = \"Relación entre PIB per cápita y Esperanza de Vida\",\n          x = \"PIB per cápita (log10)\",\n          y = \"Esperanza de Vida\",\n          color = \"Continente\")\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-69-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nOtra capa opcional que también podemos agregar es el `facet`. El facetado permite dividir el gráfico en múltiples paneles basados en una o más variables. Por ejemplo, podemos crear un gráfico separado para cada continente.\n\nUsamos `facet_wrap(~ continent)` para dividir el gráfico en múltiples paneles, uno para cada continente.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  scale_x_log10() +\n  labs(title = \"Relación entre PIB per cápita y Esperanza de Vida\",\n      x = \"PIB per cápita (log10)\",\n      y = \"Esperanza de Vida\",\n      color = \"Continente\") +\n  facet_wrap(~ continent) +\n# Puedes quitar la leyenda con esta capa adicional\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-70-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nTenemos la última capa, los themes. La capa de themes tiene una multitud de funciones que permiten modificar de forma precisa el tamaño, posición o forma de casi todos los elementos del gráfico. Por ejemplo, en el gráfico anterior eliminamos la leyenda usando un theme. Los themes permiten personalizar la apariencia del gráfico de manera detallada.Esta guía no tiene como objetivo explorar la complejidad de los themes en profundidad, así que nos centraremos en los themes predeterminados.\n\n¿Recuerdas el gráfico que generamos antes de los facets? Vamos a volver a utilizarlo para ejemplificar los diversos temas en ggplot.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  scale_x_log10() +\n  labs(title = \"Relación entre PIB per cápita y Esperanza de Vida\",\n          x = \"PIB per cápita (log10)\",\n          y = \"Esperanza de Vida\",\n          color = \"Continente\")\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-71-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nPero no tenemos que volver a escribirlo. Verás, los gráficos también son un tipo de objeto en R así que puedes ser almacenarlos en forma de una variable. De esta forma:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico = ggplot(gapminder, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  scale_x_log10() +\n  labs(title = \"Relación entre PIB per cápita y Esperanza de Vida\",\n          x = \"PIB per cápita (log10)\",\n          y = \"Esperanza de Vida\",\n          color = \"Continente\")\n```\n:::\n\n\n\n\n\nAhora solo basta con llamarlo por su recien adquirido nombre\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-73-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nComo decíamos, existen varios themes predeterminados en ggplot2. Los themes en `ggplot2` permiten personalizar la apariencia de los gráficos de manera detallada. Existen varios themes predeterminados que se pueden usar para cambiar el aspecto de los gráficos sin necesidad de realizar configuraciones complejas.\n\nYa que nombramos al objeto gráfico, podemos añadir una capa fácilmente con el signo `+`\n\nEl `theme_minimal` es un tema limpio y sencillo, con un fondo blanco y líneas de cuadrícula ligeras.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico + theme_minimal()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-74-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nEl `theme_gray` es el tema predeterminado en `ggplot2`, con un fondo gris claro y líneas de cuadrícula blancas.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico + theme_gray()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-75-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nEl `theme_bw` es similar al `theme_gray`, pero utiliza un fondo blanco y es útil para presentaciones en blanco y negro.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico + theme_bw()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-76-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nEl `theme_classic` se asemeja los gráficos clásicos de R base, con un fondo blanco y ejes negros.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico + theme_classic()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-77-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nEl `theme_void` elimina todos los elementos no esenciales del gráfico, dejando solo los datos. Es útil para gráficos personalizados donde se desea agregar y tener control de cada cosa de forma manual.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico + theme_void()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-78-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nEl `theme_dark` utiliza un fondo oscuro con líneas de cuadrícula claras.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico + theme_dark()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-79-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nCada uno de estos themes puede ser modificado y combinado con otros elementos para crear gráficos personalizados según las necesidades específicas del análisis. En particular, utilizaré el theme_minimal por preferencia personal. Pero recuerdas que puedes utilizar el que se adapte mejor a tus necesidades.\n\n### Tipos de gráficos\n\nAsí como existen diferentes tipos de variables, también hay diversos gráficos que se pueden utilizar para representarlas adecuadamente. A continuación, se presentan algunos de los gráficos más importantes y que se utilizarán en los próximos capítulos.\n\n**Gráfico de barras**\n\nUn gráfico de barras es útil para visualizar la frecuencia de categorías o la comparación de cantidades entre diferentes categorías.\n\nPara crear un gráfico de barras en R, podemos usar la función `geom_bar()`. Si solo queremos contar las observaciones en una sola variable, podemos usar `geom_bar()` sin especificar ambos ejes:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cuenta simple\nggplot(gapminder, aes(x = continent, fill = continent)) +\n  geom_bar() +\n  labs(\n    title = \"Frecuencia de países por continente\",\n    x = \"Continente\",\n    y = \"Frecuencia\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-80-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nEn este caso, el argumento `fill` se utiliza para rellenar las barras con colores diferentes según la categoría (en este caso, el continente). La diferencia entre `fill` y `color` es que `fill` se utiliza para rellenar el interior de las formas (como barras o áreas), mientras que `color` se usa para definir el color de los bordes de las formas.\n\nPero cuando queremos especificar ambos ejes, como cuando estamos comparando cantidades específicas entre categorías, usamos `geom_col` y especificamos ambos ejes en `aes`:\n\nPor ejemplo, vamos a contar el número de países en cada continente que tienen una esperanza de vida mayor a 75 años en el año 2007.\n\nPrimero preparamos los datos con `dplyr`, filtrando los datos para el año 2007 y luego contando los países por continente con una esperanza de vida mayor a 75 años.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- gapminder %>%\n  filter(year == 2007, lifeExp > 75) %>%\n  group_by(continent) %>%\n  summarise(\n    n = n_distinct(country)  # Contar el número de países únicos\n  )\n```\n:::\n\n\n\n\n\nAquí tenemos los datos preparados:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 2\n  continent     n\n  <chr>     <int>\n1 Africa        1\n2 Americas     10\n3 Asia          9\n4 Europe       22\n5 Oceania       2\n```\n\n\n:::\n:::\n\n\n\n\n\nLuego, creamos el gráfico de barras especificando ambas coordenadas con `geom_col()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Podemos usar la función reorder() para ordenar de mayor a menor en el gráfico\nggplot(datos, aes(x = reorder(continent, n), y = n, fill = continent)) +\n  geom_col() +\n  labs(title = \"Países con esperanza de vida mayor a 75 años en 2007\",\n       x = \"Continente\",\n       y = \"Número de Países\",\n       fill = \"Continente\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-83-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nPodemos invertir fácilmente el gráfico usando `coord_flip()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(datos, aes(x = reorder(continent, n), y = n, fill = continent)) +\n  geom_col() +\n  labs(title = \"Países con esperanza de vida mayor a 75 años en 2007\",\n       x = \"Continente\",\n       y = \"Número de Países\",\n       fill = \"Continente\") +\n  theme_minimal() +\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-84-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n**Histograma**\n\nUn histograma es útil para visualizar la distribución de una variable numérica. Muestra la frecuencia de valores en intervalos específicos.\n\nPara crear un histograma en R, usamos la función `geom_histogram()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder, aes(x = lifeExp)) +\n  geom_histogram(binwidth = 5, fill = \"blue\", color = \"black\") +\n  labs(title = \"Distribución de la esperanza de vida\",\n       x = \"Esperanza de vida\",\n       y = \"Frecuencia\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-85-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n**Gráfico de líneas**\n\nUn gráfico de líneas es útil para visualizar la tendencia de una variable a lo largo del tiempo.\n\nPara preparar los datos, calculamos la esperanza de vida media por año:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>%\n  group_by(year) %>%\n  summarise(lifeExp_mean = mean(lifeExp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 2\n    year lifeExp_mean\n   <dbl>        <dbl>\n 1  1952         49.1\n 2  1957         51.5\n 3  1962         53.6\n 4  1967         55.7\n 5  1972         57.6\n 6  1977         59.6\n 7  1982         61.5\n 8  1987         63.2\n 9  1992         64.2\n10  1997         65.0\n11  2002         65.7\n12  2007         67.0\n```\n\n\n:::\n:::\n\n\n\n\n\nOtra ventaja de usar `dplyr` y `ggplot` juntos es que podemos unir ambos códigos con un pipe operator. Usamos `geom_line(color = \"blue\")` para crear el gráfico de líneas:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>%\n  group_by(year) %>%\n  summarise(lifeExp_mean = mean(lifeExp)) %>%\n  ggplot(aes(x = year, y = lifeExp_mean)) +\n      geom_line(color = \"blue\") +\n  labs(title = \"Tendencia de la esperanza de vida media a lo largo del tiempo\",\n       x = \"Año\",\n       y = \"Esperanza de vida media\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-87-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n**Boxplot**\n\nUn boxplot es útil para visualizar la distribución de una variable y comparar distribuciones entre diferentes categorías. Hablaremos de él de forma mas rigurosa en el siguiente capítulo\n\nPara crear el boxplot de la esperanza de vida por continente, usamos `geom_boxplot()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder, aes(x = continent, y = lifeExp, fill = continent)) +\n  geom_boxplot() +\n  labs(title = \"Distribución de la esperanza de vida por continente\",\n       x = \"Continente\",\n       y = \"Esperanza de vida\") +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-88-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nEstos son algunos de los tipos de gráficos que utilizaremos para analizar datos en los próximos capítulos. Cada uno tiene su utilidad específica y pueden añadirse más detalles en función del objetivo que se tenga para la investigación.\n\n## Flor y el análisis del bienestar social\n\nFlor encontró un conjunto de datos abierto sobre **indicadores de bienestar social**, que incluía información reciente sobre ingresos, niveles educativos y acceso a servicios básicos en diversas regiones.\n\nFlor descargó un archivo CSV y lo IMPORTÓ a R.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nbienestar = read_csv(\"datos_bienestar.csv\")\n```\n:::\n\n\n\n\n\nAnaliza la estructura de los datos\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(bienestar)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 1,020\nColumns: 4\n$ Region               <chr> \"Sur\", \"Oeste\", \"Sur\", \"Este\", \"Este\", \"Norte\", \"~\n$ `Ingreso Mensual`    <dbl> 2018, 1705, 3321, 3101, 1293, 2424, 1783, 843, 26~\n$ `Nivel Educativo`    <chr> \"Secundaria\", \"Superior\", \"Secundaria\", \"Primaria~\n$ `Acceso a Servicios` <dbl> 73.6, 77.2, 99.5, 95.1, 62.3, 86.9, 79.1, 58.1, 9~\n```\n\n\n:::\n:::\n\n\n\n\n\nAl explorar los datos, encontró variables como:\n\n-   `region`: La región de cada observación. - `ingreso_mensual`: El ingreso promedio mensual de cada hogar.\n\n-   `nivel_educativo`: Nivel educativo mas alto alcanzado por la mayoría (Primaria, Secundaria, Superior).\n\n-   `acceso_servicios`: Porcentaje de hogares con acceso a servicios básicos (agua y electricidad).\n\nPrimero, los nombres de las columnas no eran uniformes y contenían espacios que complicaban su manipulación. Decidió solucionar estos problemas antes de continuar.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(janitor)\n\nbienestar = clean_names(bienestar)\n\ncolnames(bienestar)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"region\"             \"ingreso_mensual\"    \"nivel_educativo\"   \n[4] \"acceso_a_servicios\"\n```\n\n\n:::\n:::\n\n\n\n\n\nAdemás, al revisar el conjunto de datos, Flor notó algunos **VALORES FALTANTES** en `ingreso_mensual`. Se dispone a comprobar.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(is.na(bienestar$ingreso_mensual)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 51\n```\n\n\n:::\n:::\n\n\n\n\n\nTenemos 51 valores perdidos. En este caso en particular, tomó la decisión de eliminarlos.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\nbienestar = drop_na(bienestar)\n```\n:::\n\n\n\n\n\nFlor decidió explorar las **diferencias en el ingreso promedio por región** y cómo estas se relacionaban con el nivel educativo y el acceso a servicios básicos. Para ello tuvo que MANIPULAR los datos usando **dplyr**.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\n\n\n\nCalculó el ingreso promedio por región\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Agrupa por región y calcula el ingreso promedio\ningreso_por_region = bienestar %>%\n  group_by(region) %>%\n  summarise(ingreso_promedio = mean(ingreso_mensual))\n\ningreso_por_region\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 2\n  region ingreso_promedio\n  <chr>             <dbl>\n1 Centro            2537.\n2 Este              2408.\n3 Norte             2524.\n4 Oeste             2538.\n5 Sur               2513.\n```\n\n\n:::\n:::\n\n\n\n\n\nFlor notó que algunas regiones tenían ingresos más altos. Esto la llevó a preguntarse si el acceso a servicios básicos podría explicar parte de estas diferencias.Flor creó una tabla que mostraba el ingreso promedio y el acceso promedio a servicios básicos por región.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Agrupam por región y calcula el ingreso promedio y acceso promedio\nbienestar_region = bienestar %>%\n  group_by(region) %>%\n  summarise(\n    ingreso_promedio = mean(ingreso_mensual),\n    acceso_servicios_promedio = mean(acceso_a_servicios)\n  )\n\nbienestar_region\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n  region ingreso_promedio acceso_servicios_promedio\n  <chr>             <dbl>                     <dbl>\n1 Centro            2537.                      87.5\n2 Este              2408.                      85.8\n3 Norte             2524.                      87.9\n4 Oeste             2538.                      88.2\n5 Sur               2513.                      87.3\n```\n\n\n:::\n:::\n\n\n\n\n\nUna alternativa que planteó para simplificar la comparación fue clasificar los ingresos en \"Altos\" y \"Bajos\" según el promedio nacional. Para ello, integró la función `ifelse()` a su estructura de dplyr. `ifelse()` está estructurada para evaluar condiciones lógicas. En este caso, se escribe como `ifelse(ingreso_mensual > promedio_nacional, \"Alto\", \"Bajo\")`, donde la condición (`ingreso_mensual > promedio_nacional`) se evalúa para cada fila del vector. Si es verdadera (`TRUE`), se asigna el valor `\"Alto\"`, y si es falsa (`FALSE`), se asigna `\"Bajo\"`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcula el ingreso promedio nacional\npromedio_nacional = mean(bienestar$ingreso_mensual)\n\npromedio_nacional\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2508.653\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Crea una nueva columna con la clasificación de ingresos\nbienestar = bienestar %>%\n  mutate(\n    categoria_ingreso = \n      ifelse(ingreso_mensual > promedio_nacional, # Condición\n             \"Alto\",                              # Si la condición es verdadera\n             \"Bajo\")                              # Si la condición es falsa\n  )\n\nhead(bienestar, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 5\n   region ingreso_mensual nivel_educativo acceso_a_servicios categoria_ingreso\n   <chr>            <dbl> <chr>                        <dbl> <chr>            \n 1 Sur               2018 Secundaria                    73.6 Bajo             \n 2 Oeste             1705 Superior                      77.2 Bajo             \n 3 Sur               3321 Secundaria                    99.5 Alto             \n 4 Este              3101 Primaria                      95.1 Alto             \n 5 Este              1293 Secundaria                    62.3 Bajo             \n 6 Norte             2424 Primaria                      86.9 Bajo             \n 7 Centro            1783 Primaria                      79.1 Bajo             \n 8 Este               843 Primaria                      58.1 Bajo             \n 9 Centro            2620 Superior                      97.4 Alto             \n10 Sur               2437 Superior                      91.6 Bajo             \n```\n\n\n:::\n:::\n\n\n\n\n\n![Manipular datos es parte esencial de un análisis bien estrcuturado](images/Ilustración_sin_título%201.png){fig-align=\"center\" width=\"453\"}\n\nFlor era consciente de que podía interpretar mejor sus resultados visualmente asi que decidió usar ggplot2 para crear VISUALIZACIONES.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n:::\n\n\n\n\n\nQuería mostrar cómo variaba el ingreso promedio entre regiones. Usó `geom_col()` para crear un gráfico de barras.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Gráfico de barras del ingreso promedio por región\nggplot(ingreso_por_region, aes(x = reorder(region, ingreso_promedio), \n                               y = ingreso_promedio, \n                               fill = region)) +\n  geom_col() +\n  labs(\n    title = \"Ingreso Promedio por Región\",\n    x = \"Región\",\n    y = \"Ingreso Promedio\"\n  ) +\n  coord_flip() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-100-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nLuego, quería explorar la relación entre el ingreso y el acceso a servicios básicos.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Gráfico de dispersión por localidad\nggplot(bienestar, aes(x = acceso_a_servicios, \n                      y = ingreso_mensual, \n                      color = region)) +\n # Le puso puntos con transparencia para mejor visualización\n   geom_point(size = 3, alpha = 0.7) +  \n  labs(\n    title = \"Relación entre Acceso a Servicios Básicos e Ingreso por Localidad\",\n    x = \"Acceso a Servicios Básicos (%)\",\n    y = \"Ingreso Mensual\",\n    color = \"Región\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-101-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\nFinalmente, Flor decidió analizar cómo variaba el ingreso por nivel educativo, usando facetas para separar cada región.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Gráfico de facetas\nggplot(bienestar, aes(x = nivel_educativo, \n                      y = ingreso_mensual, \n                      fill = nivel_educativo)) +\n  geom_boxplot() +\n  facet_wrap(~ region) +\n  labs(\n    title = \"Ingreso Mensual por Nivel Educativo y Región\",\n    x = \"Nivel Educativo\",\n    y = \"Ingreso Mensual\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](integración_files/figure-pdf/unnamed-chunk-102-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n![Los gráficos nos ayudan a representar el comportamiento de nuestras variables y la relación entre ellas](images/Ilustración_sin_título%202.png){fig-align=\"center\" width=\"444\"}\n\n## Resumen del capítulo\n\nEl análisis de datos en R se estructura como un flujo lógico que empieza con la importación de datos, continúa con su limpieza, exploración y transformación, y finaliza con visualizaciones claras. En este libro el flujo lo hemos ejecutado principalmente con herramientas del *tidyverse*, una colección de paquetes diseñados para ser compatibles entre sí y mantener una sintaxis consistente.\n\nLos datos se trabajan sobre estructuras tabulares, como `data.frame` y `tibble`, que permiten manejar variables de distintos tipos. Para importar datos se utilizan funciones como `read_csv()` para archivos CSV, `read_excel()` para Excel y `read_dta()` o `read_sav()` para formatos de Stata y SPSS.\n\nLa limpieza de datos es crítica. Se identifican y eliminan valores faltantes con `is.na()` y `drop_na()`, se estandarizan nombres con `clean_names()` del paquete `janitor`, se eliminan duplicados con `distinct()` y se corrigen tipos de datos con `as.numeric()` o funciones equivalentes. La inspección estructural se apoya en funciones como `str()`, `glimpse()`, `summary()`, `head()` y `dim()`.\n\nLa transformación y manipulación se organiza mediante `dplyr`. Con `filter()` se filtran filas, `select()` permite aislar columnas, `mutate()` crea o modifica variables, `arrange()` ordena observaciones, `group_by()` agrupa por categorías, y `summarise()` / `reframe()` extrae estadísticas resumidas. El uso del operador `%>%` permite encadenar acciones una tras de otra.\n\nPara visualizar se emplea `ggplot2`, que construye gráficos en capas a partir de una gramática declarativa. Se definen las estéticas con `aes()`, se elige la geometría adecuada (`geom_point()`, `geom_col()`, `geom_histogram()`, `geom_boxplot()`...), se pueden usar facetas con `facet_wrap()`, transformar escalas como con `scale_x_log10()` y ajustar diseño con `theme_minimal()` u otros temas prediseñados. Las visualizaciones se optimizan añadiendo títulos y etiquetas con `labs()` y organizando el gráfico en objetos que pueden modificarse sucesivamente.\n\n## Ejercicios\n\n**1. Tienes un archivo llamado `datos_bienestar.csv`. ¿Cuál es la forma correcta de cargarlo en R usando el paquete `readr`?**\n\na)  `read.csv(\"datos_bienestar.csv\")`\n\nb)  `read_csv(\"datos_bienestar.csv\")`\n\nc)  `library(readr)` seguido de `read_csv(\"datos_bienestar.csv\")`\n\nd)  `library(dplyr)` seguido de `read_csv(\"datos_bienestar.csv\")`\n\n**2. Después de importar los datos, Flor notó que los nombres de las columnas contenían espacios y caracteres especiales. ¿Qué paquete y función usó para estandarizar los nombres de las columnas?**\n\na)  `tidyr` y `drop_na()`\n\nb)  `janitor` y `clean_names()`\n\nc)  `dplyr` y `mutate()`\n\nd)  `tibble` y `glimpse()`\n\n**3. ¿Cómo puedes contar cuántos valores faltantes (`NA`) hay en la columna `ingreso_mensual` de un dataframe llamado `bienestar`?**\n\na)  `sum(bienestar$ingreso_mensual == NA)`\n\nb)  `is.na(bienestar$ingreso_mensual)`\n\nc)  `sum(is.na(bienestar$ingreso_mensual))`\n\nd)  `measure(is.na(bienestar$ingreso_mensual))`\n\n**4. Flor quiere trabajar únicamente con las filas donde la región sea \"Norte\". ¿Qué código es correcto para este propósito?**\n\na)  `filter(bienestar$region == \"Norte\")`\n\nb)  `bienestar %>% filter(region == \"Norte\")`\n\nc)  `bienestar %>% select(region == \"Norte\")`\n\nd)  `bienestar %>% filter(region = \"Norte\")`\n\n**5. Flor quiere crear una nueva columna llamada `acceso_clasificado` que clasifique el acceso a servicios básicos en \"Alto\" si es mayor al 70% y \"Bajo\" si no. ¿Qué código es correcto?**\n\na)  `mutate(acceso_clasificado = ifelse(acceso_servicios > 70, \"Alto\", \"Bajo\"))`\n\nb)  `mutate(acceso_servicios = ifelse(acceso_servicios > 70, \"Alto\", \"Bajo\"))`\n\nc)  `bienestar %>% mutate(acceso_clasificado = ifelse(acceso_servicios > 70, \"Alto\", \"Bajo\"))`\n\nd)  `bienestar <- mutate(acceso_clasificado = ifelse(acceso_servicios > 70, \"Alto\", \"Bajo\"))`\n\n**6. Flor quiere calcular el ingreso promedio por región. ¿Qué código es correcto?**\n\na)  `bienestar %>% summarize(region, mean(ingreso_mensual))`\n\nb)  `group_by(bienestar$region) %>% summarize(mean(ingreso_mensual))`\n\nc)  `bienestar %>% group_by(region) %>% summarize(ingreso_promedio = mean(ingreso_mensual))`\n\nd)  `group_by(bienestar) %>% summarize(region, mean(ingreso_mensual))`\n\n**7. Flor desea visualizar el ingreso promedio por región en un gráfico de barras. ¿Qué código es correcto?**\n\na)  \n\n```         \nggplot(bienestar, aes(x = region, \n                      y = mean(ingreso_mensual))) +\n  geom_col()\n```\n\nb)  \n\n```         \nggplot(bienestar %>% \n         group_by(region) %>% \n         summarise(ingreso_promedio = mean(ingreso_mensual)),\n       aes(x = region, \n           y = ingreso_promedio)) +\n  geom_col()\n```\n\nc)  \n\n```         \nggplot(bienestar %>% \n         group_by(region), \n       aes(x = region, \n           y = mean(ingreso_mensual))) +\n  geom_bar()\n```\n\nd)  \n\n```         \nggplot(bienestar, \n       aes(x = region, \n           y = ingreso_mensual)) +\n  geom_bar(stat = \"summary\", \n           fun = \"mean\")\n```\n\n**8. Flor quiere crear un gráfico de dispersión para observar la relación entre el ingreso mensual y el acceso a servicios básicos, con puntos coloreados según la región. ¿Qué código es correcto?**\n\na)  \n\n```         \nggplot(bienestar, \n       aes(x = acceso_servicios, \n           y = ingreso_mensual, \n           color = region)) +\n  geom_point()\n```\n\nb)  \n\n```         \nggplot(bienestar, \n       aes(x = ingreso_mensual, \n           y = acceso_servicios, \n           fill = region)) +\n  geom_point()\n```\n\nc)  \n\n```         \nggplot(bienestar, \n       aes(x = acceso_servicios, \n           y = ingreso_mensual)) +\n  geom_point(color = region)\n```\n\nd)  \n\n```         \nggplot(bienestar, aes(x = acceso_servicios, \n                      y = ingreso_mensual)) +\n  geom_point(aes(color = region))\n```\n\n**9. Flor quiere analizar cómo varía el ingreso mensual según el nivel educativo en cada región. Usa facetas para separar por región. ¿Qué código es correcto?**\n\na)  \n\n```         \nggplot(bienestar, aes(x = nivel_educativo, \n                      y = ingreso_mensual, \n                      fill = nivel_educativo)) +\n  geom_boxplot() +\n  facet_grid(~ region)\n```\n\nb)  \n\n```         \nggplot(bienestar, aes(x = nivel_educativo, \n                      y = ingreso_mensual, \n                      fill = nivel_educativo)) +\n  geom_boxplot() +\n  facet_wrap(~ region)\n```\n\nc)  \n\n```         \nggplot(bienestar, aes(x = ingreso_mensual, \n                      y = nivel_educativo, \n                      fill = region)) +\n  geom_boxplot() +\n  facet_wrap(~ region)\n```\n\nd)  \n\n```         \nggplot(bienestar, aes(x = nivel_educativo, \n                      y = ingreso_mensual, \n                      fill = region)) +\n  geom_boxplot() +\n  facet_wrap(~ region)\n```\n",
    "supporting": [
      "integración_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}