<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>summary – La Datafora</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">La Datafora</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-curso-en-r" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Curso en R</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-curso-en-r">    
        <li>
    <a class="dropdown-item" href="./sesion1.html">
 <span class="dropdown-text">Sesión 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./sesion2.html">
 <span class="dropdown-text">Sesión 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./sesion3.html">
 <span class="dropdown-text">Sesión 3</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./sesion4.html">
 <span class="dropdown-text">Sesión 4</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-libro-de-estadística" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Libro de Estadística</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-libro-de-estadística">    
        <li>
    <a class="dropdown-item" href="./intro.html">
 <span class="dropdown-text">Introducción</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./summary.html">
 <span class="dropdown-text">Resumen general</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./fundamentos.html">
 <span class="dropdown-text">Fundamentos teóricos</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./fundamentosR.html">
 <span class="dropdown-text">Fundamentos en R</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./integración.qmd">
 <span class="dropdown-text">Integración conceptual</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./statdesc.html">
 <span class="dropdown-text">Estadística descriptiva</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./prob.html">
 <span class="dropdown-text">Probabilidad</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./inf.html">
 <span class="dropdown-text">Inferencia estadística</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./comp.html">
 <span class="dropdown-text">Computación aplicada</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./regr.html">
 <span class="dropdown-text">Regresión</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./glosariofunciones.html">
 <span class="dropdown-text">Glosario de funciones</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./solucionario.html">
 <span class="dropdown-text">Solucionario</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./references.html">
 <span class="dropdown-text">Referencias bibliográficas</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#estructura-del-libro" id="toc-estructura-del-libro" class="nav-link active" data-scroll-target="#estructura-del-libro">Estructura del libro</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="estructura-del-libro" class="level1 unnumbered">
<h1 class="unnumbered">Estructura del libro</h1>
<p>Este libro es para cualquier persona que desee tener una comprensión sólida de los principios y herramientas estadísticas que se utilizan habitualmente en el ámbito de la investigación, la administración pública y el mundo empresarial. Sin embargo, mi formación como politólogo me ha llevado inevitablemente a enfatizar los aspectos prácticos y empíricos, de modo que, aunque describo y explico conceptos matemáticos importantes, el libro está diseñado en última instancia para los científicos sociales que buscan trabajar con una base general y práctica para usar R en el análisis estadístico. Así que no es un libro muy profundo matemáticamente. Aquello no implica que no se haya hecho especial énfasis en que el lector pueda saber considerar herramientas pertinentes, interpretar sus resultados y reconocer las limitaciones que estos acarrean.</p>
<p>Este libro está organizado en nueve capítulos que abarcan un recorrido intencional (y espero ameno) desde los fundamentos de la estadística y la programación en R, hasta el uso de pruebas estadísticas, modelado y visualización de datos. Aunque la estructura ha sido concebida para que el lector pueda asimilar gradualmente los conceptos necesarios, también se ha procurado que cada capítulo conserve cierta autonomía. Así, el lector tiene la libertad de situarse en el punto del libro que le resulte más pertinente o familiar, siendo consciente, sin embargo, de que el nivel de dificultad incrementa de forma progresiva y que ciertos contenidos requerirán mayor dedicación al introducir nuevos conceptos. Sin más que añadir, procedo con la estructura del libro.</p>
<p><strong>Capítulo 1: Fundamentos en Estadística</strong></p>
<p>Este capítulo marca el inicio formal del recorrido. Se abordan conceptos centrales como la definición de datos, la naturaleza de las variables y la implicancia de la variabilidad, todos ellos fundamentales para comprender qué se mide y cómo. También se presenta una introducción sistemática a las técnicas de muestreo, con énfasis en sus modalidades más utilizadas. Finalmente, se introduce y explica la diferencias entre la estadística descriptiva y la estadística inferencial, estableciendo así el marco conceptual para todo lo que vendrá después.</p>
<p><strong>Capítulo 2: Fundamentos en R</strong></p>
<p>El lenguaje R será nuestra herramienta principal a lo largo del libro. En este capítulo se parte de cero: guiamos paso a paso por la instalación de R y RStudio, exploramos su interfaz y aprendemos a organizar un entorno de trabajo estructurado y reproducible. Se introducen conceptos esenciales como objetos, vectores, funciones, paquetes y operaciones básicas, todo explicado de forma accesible pero rigurosa. El enfoque es práctico: se asume que el lector no tiene experiencia previa programando, pero que sí posee el interés genuino por desarrollar habilidades reales para analizar datos con R.</p>
<p><strong>Capítulo 3: Integración</strong></p>
<p>Este capítulo representa el corazón operativo del libro. Aquí se empieza a trabajar con bases de datos reales en estructuras tipo data frame, se introduce el flujo de trabajo del Tidyverse y se consolidan los aprendizajes anteriores. Se busca que el lector aprenda a importar, limpiar, transformar y resumir datos utilizando herramientas como&nbsp;<code>readr</code>,&nbsp;<code>janitor</code>,&nbsp;<code>dplyr</code>&nbsp;y&nbsp;<code>tidyr</code>. También se aborda de forma introductoria la visualización con&nbsp;<code>ggplot2</code>, cubriendo los fundamentos de su gramática y también estrategias visuales, diseño de gráficos y mejores prácticas. Es en este capítulo donde las piezas comienzan a encajar: el lenguaje, los datos, las transformaciones y la visualización se integran de forma coherente.</p>
<p><strong>Capítulo 4: Estadística descriptiva</strong></p>
<p>Este capítulo se ocupa de todo lo relacionado con estadística descriptiva. Se desarrollan medidas de tendencia central (media, mediana, moda), dispersión (rango, varianza, desviación estándar), posición (cuartiles, percentiles) y forma de la distribución (asimetría, curtosis). También se examina el resumen de variables categóricas a través de tablas de frecuencia y proporciones. Se aplican estos conceptos en R, tanto con funciones específicas como mediante visualizaciones elaboradas con&nbsp;<code>ggplot2</code>. El capítulo culmina con una sección de análisis exploratorio univariado y bivariado, que permite al lector identificar patrones, inconsistencias y relaciones antes de avanzar hacia la inferencia.</p>
<p><strong>Capítulo 5: Probabilidad</strong></p>
<p>La probabilidad es la base de toda la inferencia estadística y aquí se busca generar una base sólida para poder comprender sus técnicas. Empezamos definiendo la probabilidad desde un enfoque frecuentista y poniendo en práctica los conceptos de la probabilidad teórica y la experimental. Proseguimos con las distribuciones de probabilidad y sus características. Se discuten distribuciones discretas y continuas (binomial, Poisson, normal), cómo trabajar con ellas en R. Luego, se hace mayor énfasis en la distribución normal, la regla empírica, cómo interpretar valores z y las áreas bajo la curva. Finalmente se introduce el teorema del límite central como puente para lo demás capítulos.</p>
<p><strong>Capítulo 6: Estadística inferencial</strong></p>
<p>A partir de aquí entramos en el terreno de las decisiones y generalizaciones. Este capítulo retoma el concepto del teorema del límite central y se concentra en su aplicación para la estimación por intervalos y el contraste de hipótesis. Se abordan también elementos clave como la significancia estadística, los valores&nbsp;<em>p</em>, los errores tipo I y II, y la validación de supuestos, todo ello acompañado de visualizaciones que buscan facilitar la comprensión e interpretación de los resultados. Se introduce la distribución&nbsp;<em>t</em>&nbsp;de Student y su uso en pruebas de hipótesis con muestras pequeñas. A lo largo del capítulo, se entrelazan los fundamentos teóricos con su aplicación en R, con el objetivo de que el lector pueda evaluar la validez de una afirmación estadística sin perder de vista la importancia del contexto.</p>
<p><strong>Capítulo 7: Comparando grupos</strong></p>
<p>Aquí se desarrollan técnicas para comparar grupos entre sí. Se estudian las diferencias entre medias y proporciones, tanto en muestras independientes como relacionadas. Se explica cómo aplicar pruebas t, ANOVA y pruebas de chi-cuadrado, abordando sus supuestos y condiciones de uso. También se introducen métodos no paramétricos para situaciones en las que los supuestos tradicionales no se cumplen. Finalmente, el lector es introducido al paquete&nbsp;<code>infer</code>, que permite hacer inferencia estadística mediante simulaciones.</p>
<p><strong>Capítulo 8: Regresión</strong></p>
<p>La regresión es una de las herramientas más populares y versátiles del análisis estadístico y no podía quedar fuera. Este capítulo comienza con la regresión lineal simple: se presenta la ecuación que la define, sus parámetros fundamentales, el proceso de estimación y las principales limitaciones del modelo. Se abordan conceptos clave como la desviación estándar condicional, la relación entre correlación y pendiente, el coeficiente de determinación y la interpretación práctica de cada término. A partir de allí, se introduce la regresión múltiple, incorporando el control de variables, el problema de la multicolinealidad y los modelos con interacción. El capítulo culmina con un breve acercamiento a los modelos lineales generalizados (GLM).</p>
<p><strong>Capítulo 9: Glosario de funciones útiles</strong></p>
<p>Este último capítulo funciona como un apéndice técnico. No está pensado para ser leído de principio a fin, sino como una guía de consulta rápida. Se organiza por bloques temáticos que incluyen funciones para vectores, data frames, limpieza de datos, manipulación con&nbsp;<code>dplyr</code>, visualización con&nbsp;<code>ggplot2</code>, paquetes complementarios a <code>ggplot2</code> para personalizar gráficos, y análisis exploratorio con&nbsp;<code>dlookr</code>. Se busca que el lector pueda encontrar rápidamente el código o función que necesita aplicar en su propio proyecto.</p>
<p>Adicionalmente, verás que a lo largo del libro, he incluido ejemplos inspirados cuestiones típicas de un investigador social los cuales están protagonizados por&nbsp;<strong>Flor</strong>, un personaje diseñado para acompañar al lector en los primeros capítulos y mostrar, desde las ciencias sociales, cómo aplicar las herramientas estadísticas para resolver problemas concretos.</p>
<p>Finalmente, mi objetivo no es que repitas fórmulas ni copies código: quiero que comprendas qué hace cada herramienta, por qué es adecuada en determinado contexto y cuáles son sus limitaciones. Al final, lo que importa no es ejecutar scripts sin errores —porque los vas a cometer, y muchos—, sino construir argumentos sólidos a partir de datos.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>